/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./build/ts/ast.js":
/*!*************************!*\
  !*** ./build/ts/ast.js ***!
  \*************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WhileStmt = exports.ReturnStmt = exports.IfStmt = exports.ForStmt = exports.FunctionStmt = exports.BlockStmt = exports.VarStmt = exports.PrintStmt = exports.ExprStmt = exports.LogicalExpr = exports.CallExpr = exports.AssignExpr = exports.NilLiteral = exports.BoolLiteral = exports.NumberLiteral = exports.StringLiteral = exports.VarExpr = exports.UnaryExpr = exports.BinaryExpr = exports.LogicalOperator = exports.UnaryOperator = exports.BinaryOperator = void 0;\nvar BinaryOperator;\n(function (BinaryOperator) {\n    BinaryOperator[BinaryOperator[\"Plus\"] = 0] = \"Plus\";\n    BinaryOperator[BinaryOperator[\"Minus\"] = 1] = \"Minus\";\n    BinaryOperator[BinaryOperator[\"Star\"] = 2] = \"Star\";\n    BinaryOperator[BinaryOperator[\"Slash\"] = 3] = \"Slash\";\n    BinaryOperator[BinaryOperator[\"Less\"] = 4] = \"Less\";\n    BinaryOperator[BinaryOperator[\"Greater\"] = 5] = \"Greater\";\n    BinaryOperator[BinaryOperator[\"LessEqual\"] = 6] = \"LessEqual\";\n    BinaryOperator[BinaryOperator[\"GreaterEqual\"] = 7] = \"GreaterEqual\";\n    BinaryOperator[BinaryOperator[\"EqualEqual\"] = 8] = \"EqualEqual\";\n    BinaryOperator[BinaryOperator[\"BangEqual\"] = 9] = \"BangEqual\";\n})(BinaryOperator = exports.BinaryOperator || (exports.BinaryOperator = {}));\nvar UnaryOperator;\n(function (UnaryOperator) {\n    UnaryOperator[UnaryOperator[\"Minus\"] = 0] = \"Minus\";\n    UnaryOperator[UnaryOperator[\"Bang\"] = 1] = \"Bang\";\n})(UnaryOperator = exports.UnaryOperator || (exports.UnaryOperator = {}));\nvar LogicalOperator;\n(function (LogicalOperator) {\n    LogicalOperator[LogicalOperator[\"And\"] = 0] = \"And\";\n    LogicalOperator[LogicalOperator[\"Or\"] = 1] = \"Or\";\n})(LogicalOperator = exports.LogicalOperator || (exports.LogicalOperator = {}));\nclass BinaryExpr {\n    constructor(span, left, right, op) {\n        this.span = span;\n        this.left = left;\n        this.right = right;\n        this.op = op;\n    }\n    accept(visitor) { return visitor.visitBinaryExpr(this); }\n}\nexports.BinaryExpr = BinaryExpr;\nclass UnaryExpr {\n    constructor(span, operator, operand) {\n        this.span = span;\n        this.operator = operator;\n        this.operand = operand;\n    }\n    accept(visitor) { return visitor.visitUnaryExpr(this); }\n}\nexports.UnaryExpr = UnaryExpr;\nclass VarExpr {\n    constructor(span, name) {\n        this.span = span;\n        this.name = name;\n    }\n    accept(visitor) { return visitor.visitVarExpr(this); }\n}\nexports.VarExpr = VarExpr;\nclass StringLiteral {\n    constructor(span, value) {\n        this.span = span;\n        this.value = value;\n    }\n    accept(visitor) { return visitor.visitStringLiteral(this); }\n}\nexports.StringLiteral = StringLiteral;\nclass NumberLiteral {\n    constructor(span, value) {\n        this.span = span;\n        this.value = value;\n    }\n    accept(visitor) { return visitor.visitNumberLiteral(this); }\n}\nexports.NumberLiteral = NumberLiteral;\nclass BoolLiteral {\n    constructor(span, value) {\n        this.span = span;\n        this.value = value;\n    }\n    accept(visitor) { return visitor.visitBoolLiteral(this); }\n}\nexports.BoolLiteral = BoolLiteral;\nclass NilLiteral {\n    constructor(span) {\n        this.span = span;\n    }\n    accept(visitor) { return visitor.visitNilLiteral(this); }\n}\nexports.NilLiteral = NilLiteral;\nclass AssignExpr {\n    constructor(span, name, value) {\n        this.span = span;\n        this.name = name;\n        this.value = value;\n    }\n    accept(visitor) { return visitor.visitAssignExpr(this); }\n}\nexports.AssignExpr = AssignExpr;\nclass CallExpr {\n    constructor(span, callee, args) {\n        this.span = span;\n        this.callee = callee;\n        this.args = args;\n    }\n    accept(visitor) { return visitor.visitCallExpr(this); }\n}\nexports.CallExpr = CallExpr;\n// export class GetExpr implements Expr {\n// constructor(public span: diagnostics.Span, public object: Expr, public name: string) {}\n// accept<T>(visitor: ExprVisitor<T>) { return visitor.visitGetExpr(this); }\n// }\nclass LogicalExpr {\n    constructor(span, left, operator, right) {\n        this.span = span;\n        this.left = left;\n        this.operator = operator;\n        this.right = right;\n    }\n    accept(visitor) { return visitor.visitLogicalExpr(this); }\n}\nexports.LogicalExpr = LogicalExpr;\nclass ExprStmt {\n    constructor(span, expr) {\n        this.span = span;\n        this.expr = expr;\n    }\n    accept(visitor) { return visitor.visitExprStmt(this); }\n}\nexports.ExprStmt = ExprStmt;\nclass PrintStmt {\n    constructor(span, expr) {\n        this.span = span;\n        this.expr = expr;\n    }\n    accept(visitor) { return visitor.visitPrintStmt(this); }\n}\nexports.PrintStmt = PrintStmt;\nclass VarStmt {\n    constructor(span, name, initializer) {\n        this.span = span;\n        this.name = name;\n        this.initializer = initializer;\n    }\n    accept(visitor) { return visitor.visitVarStmt(this); }\n}\nexports.VarStmt = VarStmt;\nclass BlockStmt {\n    constructor(span, stmts, obrace_sp, cbrace_sp) {\n        this.span = span;\n        this.stmts = stmts;\n        this.obrace_sp = obrace_sp;\n        this.cbrace_sp = cbrace_sp;\n    }\n    accept(visitor) { return visitor.visitBlockStmt(this); }\n}\nexports.BlockStmt = BlockStmt;\n// export class ClassStmt implements Stmt {\n// constructor(public span: diagnostics.Span, name: string, List<Stmt.Function> methods) {}\n// accept<T>(visitor: StmtVisitor<T>) { return visitor.visitClassStmt(this); }\n// }\nclass FunctionStmt {\n    constructor(span, name, params, body) {\n        this.span = span;\n        this.name = name;\n        this.params = params;\n        this.body = body;\n    }\n    accept(visitor) { return visitor.visitFunctionStmt(this); }\n}\nexports.FunctionStmt = FunctionStmt;\nclass ForStmt {\n    constructor(span, initializer, compare, increment, body, for_sp) {\n        this.span = span;\n        this.initializer = initializer;\n        this.compare = compare;\n        this.increment = increment;\n        this.body = body;\n        this.for_sp = for_sp;\n    }\n    accept(visitor) { return visitor.visitForStmt(this); }\n}\nexports.ForStmt = ForStmt;\nclass IfStmt {\n    constructor(span, condition, then_branch, else_branch) {\n        this.span = span;\n        this.condition = condition;\n        this.then_branch = then_branch;\n        this.else_branch = else_branch;\n    }\n    accept(visitor) { return visitor.visitIfStmt(this); }\n}\nexports.IfStmt = IfStmt;\nclass ReturnStmt {\n    constructor(span, value) {\n        this.span = span;\n        this.value = value;\n    }\n    accept(visitor) { return visitor.visitReturnStmt(this); }\n}\nexports.ReturnStmt = ReturnStmt;\nclass WhileStmt {\n    constructor(span, condition, body) {\n        this.span = span;\n        this.condition = condition;\n        this.body = body;\n    }\n    accept(visitor) { return visitor.visitWhileStmt(this); }\n}\nexports.WhileStmt = WhileStmt;\n\n\n//# sourceURL=webpack://thing/./build/ts/ast.js?");

/***/ }),

/***/ "./build/ts/bytecode.js":
/*!******************************!*\
  !*** ./build/ts/bytecode.js ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PrettyPrintContext = exports.StmtMarker = exports.UnaryOp = exports.BinaryOp = exports.Call = exports.Assign = exports.ReadVar = exports.EndScope = exports.StartScope = exports.Return = exports.If = exports.While = exports.MakeVar = exports.Print = exports.Constant = exports.Function = exports.Nil = exports.Register = void 0;\nconst diagnostics = __importStar(__webpack_require__(/*! ./diagnostics */ \"./build/ts/diagnostics.js\"));\nconst ast = __importStar(__webpack_require__(/*! ./ast */ \"./build/ts/ast.js\"));\nclass Register {\n    constructor(index) {\n        this.index = index;\n    }\n    pretty_print() { return `%${this.index}`; }\n}\nexports.Register = Register;\nclass Nil {\n    constructor() { }\n    pretty_print() { return 'nil'; }\n}\nexports.Nil = Nil;\nclass Function {\n    constructor(name, params, instructions) {\n        this.name = name;\n        this.params = params;\n        this.instructions = instructions;\n    }\n    pretty_print() { return `<function '${this.name}'>`; }\n}\nexports.Function = Function;\nclass Constant {\n    constructor(x) {\n        this.x = x;\n    }\n    pretty_print() { return this.x; }\n}\nexports.Constant = Constant;\nclass Print {\n    constructor(span, expr) {\n        this.span = span;\n        this.expr = expr;\n    }\n    pretty_print(ppc) {\n        ppc.append(`print ${this.expr.pretty_print()};`, this.span);\n    }\n}\nexports.Print = Print;\nclass MakeVar {\n    constructor(span, name, value) {\n        this.span = span;\n        this.name = name;\n        this.value = value;\n    }\n    pretty_print(ppc) {\n        ppc.append(`make_var ${this.name} = ${this.value.pretty_print()};`, this.span);\n    }\n}\nexports.MakeVar = MakeVar;\nclass While {\n    constructor(span, check_code, check, body_code) {\n        this.span = span;\n        this.check_code = check_code;\n        this.check = check;\n        this.body_code = body_code;\n    }\n    pretty_print(ppc) {\n        ppc.append('while {', this.span);\n        ppc.indent();\n        ppc.pretty_print_instrs(this.check_code);\n        ppc.append_no_span(`check ${this.check.pretty_print()}`);\n        ppc.dedent();\n        ppc.append_no_span('}');\n        ppc.append_no_span('{');\n        ppc.indent();\n        ppc.pretty_print_instrs(this.body_code);\n        ppc.dedent();\n        ppc.append_no_span('}');\n    }\n}\nexports.While = While;\nclass If {\n    constructor(span, cond, true_branch, false_branch) {\n        this.span = span;\n        this.cond = cond;\n        this.true_branch = true_branch;\n        this.false_branch = false_branch;\n    }\n    pretty_print(ppc) {\n        ppc.append('if ${this.cond.pretty_print()} {', this.span);\n        ppc.indent();\n        ppc.pretty_print_instrs(this.true_branch);\n        ppc.dedent();\n        if (this.false_branch) {\n            ppc.append_no_span('} else {');\n            ppc.indent();\n            ppc.pretty_print_instrs(this.false_branch);\n            ppc.dedent();\n            ppc.append_no_span('}');\n        }\n        else {\n            ppc.append_no_span('}');\n        }\n    }\n}\nexports.If = If;\nclass Return {\n    constructor(span, v) {\n        this.span = span;\n        this.v = v;\n    }\n    pretty_print(ppc) {\n        ppc.append(`return ${this.v.pretty_print()};`, this.span);\n    }\n}\nexports.Return = Return;\nclass StartScope {\n    constructor(span) {\n        this.span = span;\n    }\n    pretty_print(ppc) {\n        ppc.append(`start_scope;`, this.span);\n    }\n}\nexports.StartScope = StartScope;\nclass EndScope {\n    constructor(span) {\n        this.span = span;\n    }\n    pretty_print(ppc) {\n        ppc.append(`end_scope;`, this.span);\n    }\n}\nexports.EndScope = EndScope;\nclass ReadVar {\n    constructor(span, v, dest) {\n        this.span = span;\n        this.v = v;\n        this.dest = dest;\n    }\n    pretty_print(ppc) {\n        ppc.append(`read_var ${this.v} -> ${this.dest.pretty_print()};`, this.span);\n    }\n}\nexports.ReadVar = ReadVar;\nclass Assign {\n    constructor(span, variable, value) {\n        this.span = span;\n        this.variable = variable;\n        this.value = value;\n    }\n    pretty_print(ppc) {\n        ppc.append(`assign ${this.variable} = ${this.value.pretty_print()};`, this.span);\n    }\n}\nexports.Assign = Assign;\nclass Call {\n    constructor(span, callee, args, dest) {\n        this.span = span;\n        this.callee = callee;\n        this.args = args;\n        this.dest = dest;\n    }\n    pretty_print(ppc) {\n        ppc.append(`call ${this.callee.pretty_print()}(${this.args.map(a => a.pretty_print()).join()}) -> ${this.dest.pretty_print()};`, this.span);\n    }\n}\nexports.Call = Call;\nclass BinaryOp {\n    constructor(span, l, r, op, dest) {\n        this.span = span;\n        this.l = l;\n        this.r = r;\n        this.op = op;\n        this.dest = dest;\n    }\n    pretty_print(ppc) {\n        let op_name;\n        switch (this.op) {\n            case ast.BinaryOperator.Plus:\n                op_name = 'add';\n                break;\n            case ast.BinaryOperator.Minus:\n                op_name = 'sub';\n                break;\n            case ast.BinaryOperator.Star:\n                op_name = 'mul';\n                break;\n            case ast.BinaryOperator.Slash:\n                op_name = 'div';\n                break;\n            case ast.BinaryOperator.Less:\n                op_name = 'cmp<';\n                break;\n            case ast.BinaryOperator.Greater:\n                op_name = 'cmp>';\n                break;\n            case ast.BinaryOperator.LessEqual:\n                op_name = 'cmp<=';\n                break;\n            case ast.BinaryOperator.EqualEqual:\n                op_name = 'cmp==';\n                break;\n            case ast.BinaryOperator.GreaterEqual:\n                op_name = 'cmp>=';\n                break;\n            case ast.BinaryOperator.BangEqual:\n                op_name = 'cmp!=';\n                break;\n        }\n        ppc.append(`${op_name} ${this.l.pretty_print()} ${this.r.pretty_print()} -> ${this.dest.pretty_print()};`, this.span);\n    }\n}\nexports.BinaryOp = BinaryOp;\nclass UnaryOp {\n    constructor(span, v, op, dest) {\n        this.span = span;\n        this.v = v;\n        this.op = op;\n        this.dest = dest;\n    }\n    pretty_print(ppc) {\n        let op_name;\n        switch (this.op) {\n            case ast.UnaryOperator.Minus:\n                op_name = 'neg';\n                break;\n            case ast.UnaryOperator.Bang:\n                op_name = 'logic_neg';\n                break;\n        }\n        ppc.append(`${op_name} ${this.v.pretty_print()} -> ${this.dest.pretty_print()};`, this.span);\n    }\n}\nexports.UnaryOp = UnaryOp;\nclass StmtMarker {\n    constructor(span) {\n        this.span = span;\n    }\n    pretty_print(ppc) {\n        ppc.append_marker(`// line ${this.span.start_line}: ${diagnostics.get_line(this.span.source, this.span.start_line)}`);\n    }\n}\nexports.StmtMarker = StmtMarker;\nclass PrettyPrintContext {\n    constructor() {\n        this.indentation = 0;\n        this.result = '';\n    }\n    indent() {\n        ++this.indentation;\n    }\n    dedent() {\n        --this.indentation;\n    }\n    blank_line() {\n        this.result += '\\n';\n    }\n    append(s, sp) {\n        let sp_contents = sp.contents;\n        let sp_annotation = sp_contents.split('\\n').length > 1 ? `${sp_contents.split('\\n')[0]}...` : sp_contents;\n        this.append_no_span(`${s}${' '.repeat(40 - s.length)}// ${sp_annotation}`);\n    }\n    append_no_span(s) {\n        this.result += `${' '.repeat(this.indentation * 4)}${s}\\n`;\n    }\n    append_marker(s) {\n        this.blank_line();\n        this.append_no_span(s);\n    }\n    pretty_print_instrs(instrs) {\n        for (let instr of instrs) {\n            instr.pretty_print(this);\n        }\n    }\n}\nexports.PrettyPrintContext = PrettyPrintContext;\n\n\n//# sourceURL=webpack://thing/./build/ts/bytecode.js?");

/***/ }),

/***/ "./build/ts/compiler.js":
/*!******************************!*\
  !*** ./build/ts/compiler.js ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.compile = void 0;\nconst bytecode = __importStar(__webpack_require__(/*! ./bytecode */ \"./build/ts/bytecode.js\"));\nclass RegisterContext {\n    constructor() {\n        this.register_i = 0;\n    }\n    new_register() {\n        return new bytecode.Register(this.register_i++);\n    }\n}\nclass Compiler {\n    constructor(register_context) {\n        this.register_context = register_context;\n        this.instructions = [];\n    }\n    compile_stmt(stmt) {\n        stmt.accept(this);\n    }\n    compile_expr(expr) {\n        return expr.accept(this);\n    }\n    make_stmt_marker(stmt) {\n        this.instruction(new bytecode.StmtMarker(stmt.span));\n    }\n    visitExprStmt(stmt) {\n        this.make_stmt_marker(stmt);\n        this.compile_expr(stmt.expr);\n    }\n    visitPrintStmt(stmt) {\n        this.make_stmt_marker(stmt);\n        let e = this.compile_expr(stmt.expr);\n        this.instruction(new bytecode.Print(stmt.span, e));\n    }\n    visitVarStmt(stmt) {\n        this.make_stmt_marker(stmt);\n        let e;\n        if (stmt.initializer) {\n            e = this.compile_expr(stmt.initializer);\n        }\n        else {\n            e = new bytecode.Nil();\n        }\n        this.instruction(new bytecode.MakeVar(stmt.span, stmt.name, e));\n    }\n    visitBlockStmt(stmt) {\n        this.make_stmt_marker(stmt);\n        this.instruction(new bytecode.StartScope(stmt.obrace_sp));\n        for (let sub_stmt of stmt.stmts) {\n            sub_stmt.accept(this);\n        }\n        this.instruction(new bytecode.EndScope(stmt.cbrace_sp));\n    }\n    visitFunctionStmt(stmt) {\n        this.make_stmt_marker(stmt);\n        let register_context = new RegisterContext();\n        let fn_compiler = new Compiler(register_context);\n        fn_compiler.compile_stmt(stmt.body);\n        let fn = new bytecode.Function(stmt.name, stmt.params, fn_compiler.instructions);\n        this.instruction(new bytecode.MakeVar(stmt.span, stmt.name, fn));\n    }\n    visitForStmt(stmt) {\n        this.make_stmt_marker(stmt);\n        this.instruction(new bytecode.StartScope(stmt.for_sp));\n        if (stmt.initializer) {\n            this.compile_stmt(stmt.initializer);\n        }\n        let check_compiler = new Compiler(this.register_context);\n        let check;\n        if (stmt.compare) {\n            check = check_compiler.compile_expr(stmt.compare);\n        }\n        else {\n            check = new bytecode.Constant(true);\n        }\n        let body_compiler = new Compiler(this.register_context);\n        body_compiler.compile_stmt(stmt.body);\n        if (stmt.increment) {\n            body_compiler.compile_expr(stmt.increment);\n        }\n        this.instruction(new bytecode.While(stmt.span, check_compiler.instructions, check, body_compiler.instructions));\n        this.instruction(new bytecode.EndScope(stmt.for_sp)); // TODO: better span?\n    }\n    visitIfStmt(stmt) {\n        this.make_stmt_marker(stmt);\n        let cond = this.compile_expr(stmt.condition);\n        let true_compiler = new Compiler(this.register_context);\n        true_compiler.compile_stmt(stmt.then_branch);\n        let false_compiler;\n        if (stmt.else_branch) {\n            false_compiler = new Compiler(this.register_context);\n            false_compiler.compile_stmt(stmt.else_branch);\n        }\n        else {\n            false_compiler = null;\n        }\n        this.instruction(new bytecode.If(stmt.span, cond, true_compiler.instructions, false_compiler ? false_compiler.instructions : null));\n    }\n    visitReturnStmt(stmt) {\n        this.make_stmt_marker(stmt);\n        let e;\n        if (stmt.value) {\n            e = this.compile_expr(stmt.value);\n        }\n        else {\n            e = new bytecode.Nil();\n        }\n        this.instruction(new bytecode.Return(stmt.span, e));\n    }\n    visitWhileStmt(stmt) {\n        this.make_stmt_marker(stmt);\n        let check_compiler = new Compiler(this.register_context);\n        let check = check_compiler.compile_expr(stmt.condition);\n        let body_compiler = new Compiler(this.register_context);\n        body_compiler.compile_stmt(stmt.body);\n        this.instruction(new bytecode.While(stmt.span, check_compiler.instructions, check, body_compiler.instructions));\n    }\n    visitBinaryExpr(expr) {\n        let l = this.compile_expr(expr.left);\n        let r = this.compile_expr(expr.right);\n        let reg = this.register_context.new_register();\n        this.instruction(new bytecode.BinaryOp(expr.span, l, r, expr.op, reg));\n        return reg;\n    }\n    visitUnaryExpr(expr) {\n        let v = this.compile_expr(expr.operand);\n        let reg = this.register_context.new_register();\n        this.instruction(new bytecode.UnaryOp(expr.span, v, expr.operator, reg));\n        return reg;\n    }\n    visitVarExpr(expr) {\n        let reg = this.register_context.new_register();\n        this.instruction(new bytecode.ReadVar(expr.span, expr.name, reg));\n        return reg;\n    }\n    visitStringLiteral(expr) {\n        return new bytecode.Constant(expr.value);\n    }\n    visitNumberLiteral(expr) {\n        return new bytecode.Constant(expr.value);\n    }\n    visitBoolLiteral(expr) {\n        return new bytecode.Constant(expr.value);\n    }\n    visitNilLiteral(expr) {\n        return new bytecode.Nil();\n    }\n    visitAssignExpr(expr) {\n        let v = this.compile_expr(expr.value);\n        this.instruction(new bytecode.Assign(expr.span, expr.name, v));\n        return v;\n    }\n    visitCallExpr(expr) {\n        console.log(expr);\n        let callee = this.compile_expr(expr.callee);\n        let args = [];\n        for (let a_ast of expr.args) {\n            args.push(this.compile_expr(a_ast));\n        }\n        let reg = this.register_context.new_register();\n        this.instruction(new bytecode.Call(expr.span, callee, args, reg));\n        return reg;\n    }\n    visitLogicalExpr(expr) {\n        throw new Error(\"not implemented yet\"); // TODO\n    }\n    instruction(instr) {\n        this.instructions.push(instr);\n    }\n}\nfunction compile(stmts) {\n    let register_context = new RegisterContext();\n    let compiler = new Compiler(register_context);\n    for (let stmt of stmts) {\n        compiler.compile_stmt(stmt);\n    }\n    return compiler.instructions;\n}\nexports.compile = compile;\n\n\n//# sourceURL=webpack://thing/./build/ts/compiler.js?");

/***/ }),

/***/ "./build/ts/diagnostics.js":
/*!*********************************!*\
  !*** ./build/ts/diagnostics.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.report = exports.join_spans = exports.clear = exports.get_line = exports.Span = void 0;\nconst errors_div = document.getElementById('errors');\nclass Span {\n    constructor(source, start, end) {\n        this.source = source;\n        this.start = start;\n        this.end = end;\n        [this.start_line, this.start_column] = get_linecol(source, start);\n        [this.end_line, this.end_column] = get_linecol(source, end);\n        this.contents = source.substring(start, end);\n    }\n}\nexports.Span = Span;\nfunction get_linecol(source, ind) {\n    let line = (source.substring(0, ind).match(/^/mg) || []).length;\n    let lines = source.substring(0, ind).match(/^.+/mg);\n    if (lines) {\n        return [line, lines[lines.length - 1].length + 1];\n    }\n    else {\n        return [line, 0];\n    }\n}\nfunction get_line(source, line) {\n    return source.split('\\n')[line - 1];\n}\nexports.get_line = get_line;\nfunction clear() {\n    while (errors_div.lastChild) {\n        errors_div.removeChild(errors_div.lastChild);\n    }\n}\nexports.clear = clear;\nfunction join_spans(sp1, sp2) {\n    return new Span(sp1.source, Math.min(sp1.start, sp2.start), Math.max(sp1.end, sp2.end));\n}\nexports.join_spans = join_spans;\nfunction report(diagnostic) {\n    let div = document.createElement('div');\n    div.className = 'error';\n    {\n        let heading = document.createElement('p');\n        heading.className = 'error_heading';\n        heading.innerHTML = `error at ${diagnostic.span.start_line}:${diagnostic.span.start_column}: ${diagnostic.message}`;\n        div.appendChild(heading);\n    }\n    {\n        function make_line_view(source, nr, highlight_start_col, highlight_end_col) {\n            let line_view = document.createElement('div');\n            line_view.className = 'error_line_view';\n            let line_number = document.createElement('p');\n            line_number.innerHTML = nr.toString();\n            line_number.className = 'error_linenumber';\n            let pre = document.createElement('pre');\n            let code = document.createElement('code');\n            pre.className = 'error_pre';\n            code.className = 'error_code';\n            if (highlight_start_col == null || highlight_end_col == null) {\n                code.innerHTML = source[nr - 1];\n            }\n            else {\n                let line_contents = source[nr - 1];\n                let start = highlight_start_col - 1;\n                let end = highlight_end_col == -1 ? line_contents.length : highlight_end_col - 1;\n                code.innerHTML = `${line_contents.substring(0, start)}<strong>${line_contents.substring(start, end)}</strong>${line_contents.substring(end)}`;\n            }\n            line_view.appendChild(line_number);\n            pre.appendChild(code);\n            line_view.appendChild(pre);\n            return line_view;\n        }\n        let view = document.createElement('div');\n        view.className = 'error_view';\n        let source_lines = diagnostic.span.source.split('\\n');\n        for (let i = diagnostic.span.start_line; i <= diagnostic.span.end_line; ++i) {\n            let highlight_start_col = diagnostic.span.start_line == i ? diagnostic.span.start_column :\n                diagnostic.span.start_line < i ? 0 : null;\n            let highlight_end_col = diagnostic.span.end_line == i ? diagnostic.span.end_column :\n                diagnostic.span.end_line < i ? null : -1;\n            view.appendChild(make_line_view(source_lines, i, highlight_start_col, highlight_end_col));\n        }\n        div.appendChild(view);\n    }\n    if (diagnostic.explanation) {\n        let explanation = document.createElement('p');\n        explanation.className = 'error_explanation';\n        explanation.innerHTML = diagnostic.explanation;\n        div.appendChild(explanation);\n    }\n    errors_div.appendChild(div);\n}\nexports.report = report;\n\n\n//# sourceURL=webpack://thing/./build/ts/diagnostics.js?");

/***/ }),

/***/ "./build/ts/lexer.js":
/*!***************************!*\
  !*** ./build/ts/lexer.js ***!
  \***************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.lex = exports.EOF = exports.BoolLiteral = exports.NumberLiteral = exports.StringLiteral = exports.Identifier = exports.While = exports.Var = exports.This = exports.Super = exports.Return = exports.Print = exports.Or = exports.Nil = exports.If = exports.Fun = exports.For = exports.Else = exports.Class = exports.And = exports.BangEqual = exports.GreaterEqual = exports.EqualEqual = exports.LessEqual = exports.Bang = exports.Greater = exports.Equal = exports.Less = exports.Semicolon = exports.CBrace = exports.OBrace = exports.Slash = exports.Star = exports.Minus = exports.Plus = exports.Dot = exports.Comma = exports.CParen = exports.OParen = void 0;\nconst diagnostics = __importStar(__webpack_require__(/*! ./diagnostics */ \"./build/ts/diagnostics.js\"));\nclass OParen {\n    constructor() {\n        this.type = \"'('\";\n    }\n}\nexports.OParen = OParen;\nclass CParen {\n    constructor() {\n        this.type = \"')'\";\n    }\n}\nexports.CParen = CParen;\nclass Comma {\n    constructor() {\n        this.type = \"','\";\n    }\n}\nexports.Comma = Comma;\nclass Dot {\n    constructor() {\n        this.type = \"'.'\";\n    }\n}\nexports.Dot = Dot;\nclass Plus {\n    constructor() {\n        this.type = \"'+'\";\n    }\n}\nexports.Plus = Plus;\nclass Minus {\n    constructor() {\n        this.type = \"'-'\";\n    }\n}\nexports.Minus = Minus;\nclass Star {\n    constructor() {\n        this.type = \"'*'\";\n    }\n}\nexports.Star = Star;\nclass Slash {\n    constructor() {\n        this.type = \"'/'\";\n    }\n}\nexports.Slash = Slash;\nclass OBrace {\n    constructor() {\n        this.type = \"'{'\";\n    }\n}\nexports.OBrace = OBrace;\nclass CBrace {\n    constructor() {\n        this.type = \"'}'\";\n    }\n}\nexports.CBrace = CBrace;\nclass Semicolon {\n    constructor() {\n        this.type = \"';'\";\n    }\n}\nexports.Semicolon = Semicolon;\nclass Less {\n    constructor() {\n        this.type = \"'<'\";\n    }\n}\nexports.Less = Less;\nclass Equal {\n    constructor() {\n        this.type = \"'='\";\n    }\n}\nexports.Equal = Equal;\nclass Greater {\n    constructor() {\n        this.type = \"'>'\";\n    }\n}\nexports.Greater = Greater;\nclass Bang {\n    constructor() {\n        this.type = \"'!'\";\n    }\n}\nexports.Bang = Bang;\nclass LessEqual {\n    constructor() {\n        this.type = \"'<='\";\n    }\n}\nexports.LessEqual = LessEqual;\nclass EqualEqual {\n    constructor() {\n        this.type = \"'=='\";\n    }\n}\nexports.EqualEqual = EqualEqual;\nclass GreaterEqual {\n    constructor() {\n        this.type = \"'>='\";\n    }\n}\nexports.GreaterEqual = GreaterEqual;\nclass BangEqual {\n    constructor() {\n        this.type = \"'!='\";\n    }\n}\nexports.BangEqual = BangEqual;\nclass And {\n    constructor() {\n        this.type = \"'and'\";\n    }\n}\nexports.And = And;\nclass Class {\n    constructor() {\n        this.type = \"'class'\";\n    }\n}\nexports.Class = Class;\nclass Else {\n    constructor() {\n        this.type = \"'else'\";\n    }\n}\nexports.Else = Else;\nclass For {\n    constructor() {\n        this.type = \"'for'\";\n    }\n}\nexports.For = For;\nclass Fun {\n    constructor() {\n        this.type = \"'fun'\";\n    }\n}\nexports.Fun = Fun;\nclass If {\n    constructor() {\n        this.type = \"'if'\";\n    }\n}\nexports.If = If;\nclass Nil {\n    constructor() {\n        this.type = \"'nil'\";\n    }\n}\nexports.Nil = Nil;\nclass Or {\n    constructor() {\n        this.type = \"'or'\";\n    }\n}\nexports.Or = Or;\nclass Print {\n    constructor() {\n        this.type = \"'print'\";\n    }\n}\nexports.Print = Print;\nclass Return {\n    constructor() {\n        this.type = \"'return'\";\n    }\n}\nexports.Return = Return;\nclass Super {\n    constructor() {\n        this.type = \"'super'\";\n    }\n}\nexports.Super = Super;\nclass This {\n    constructor() {\n        this.type = \"'this'\";\n    }\n}\nexports.This = This;\nclass Var {\n    constructor() {\n        this.type = \"'var'\";\n    }\n}\nexports.Var = Var;\nclass While {\n    constructor() {\n        this.type = \"'while'\";\n    }\n}\nexports.While = While;\nclass Identifier {\n    constructor(name) {\n        this.name = name;\n        this.type = \"identifier\";\n    }\n}\nexports.Identifier = Identifier;\nclass StringLiteral {\n    constructor(str) {\n        this.str = str;\n        this.type = \"string literal\";\n    }\n}\nexports.StringLiteral = StringLiteral;\nclass NumberLiteral {\n    constructor(num) {\n        this.num = num;\n        this.type = \"number literal\";\n    }\n}\nexports.NumberLiteral = NumberLiteral;\nclass BoolLiteral {\n    constructor(bool) {\n        this.bool = bool;\n        this.type = \"bool literal\";\n    }\n}\nexports.BoolLiteral = BoolLiteral;\nclass EOF {\n    constructor() {\n        this.type = \"eof\";\n    }\n}\nexports.EOF = EOF;\nclass BadCharacter {\n    constructor(ch) {\n        this.ch = ch;\n        this.message = `bad character: ${ch}`;\n        this.explanation = null;\n    }\n}\nclass UnterminatedString {\n    constructor() { this.message = \"unterminated string\"; this.explanation = null; }\n}\nclass Lexer {\n    constructor(source) {\n        this.source = source;\n        this.source = source;\n        this.ind = 0;\n    }\n    lex() {\n        let tokens = [];\n        while (!this.at_end()) {\n            let tok_start = this.ind;\n            let tok = this.lex_single_token(tok_start);\n            let tok_end = this.ind;\n            if (tok != null) {\n                tokens.push(Object.assign({ span: new diagnostics.Span(this.source, tok_start, tok_end) }, tok));\n            }\n        }\n        let eof = Object.assign(Object.assign({}, new EOF()), { span: this.span(this.ind) });\n        return [tokens, eof];\n    }\n    lex_single_token(start_ind) {\n        let c = this.advance();\n        if (c == null) {\n            return null;\n        }\n        switch (c) {\n            case '(': return new OParen();\n            case ')': return new CParen();\n            case ',': return new Comma();\n            case '.': return new Dot();\n            case '+': return new Plus();\n            case '-': return new Minus();\n            case '*': return new Star();\n            case '/':\n                if (this.match('/')) {\n                    while (!this.at_end() && this.peek() != '\\n') {\n                        this.advance();\n                    }\n                    ;\n                    return null;\n                }\n                else {\n                    return new Slash();\n                }\n            case '{': return new OBrace();\n            case '}': return new CBrace();\n            case ';': return new Semicolon();\n            case ' ':\n            case '\\n':\n            case '\\r':\n            case '\\t':\n                return null;\n            case '!': return this.match('=') ? new BangEqual() : new Bang();\n            case '=': return this.match('=') ? new EqualEqual() : new Equal();\n            case '<': return this.match('=') ? new LessEqual() : new Less();\n            case '>': return this.match('=') ? new GreaterEqual() : new Greater();\n            case '\"': return this.string(start_ind);\n            default:\n                if (this.is_digit(c)) {\n                    return this.number();\n                }\n                else if (this.is_alpha(c)) {\n                    return this.identifier();\n                }\n                else {\n                    diagnostics.report(Object.assign(Object.assign({}, new BadCharacter(c)), { span: this.span(start_ind) }));\n                    return null;\n                }\n        }\n    }\n    string(start_ind) {\n        let lit_start = this.ind;\n        while (!this.at_end() && this.peek() != '\"') {\n            this.advance();\n        }\n        if (this.at_end()) {\n            diagnostics.report(Object.assign(Object.assign({}, new UnterminatedString()), { span: this.span(start_ind) }));\n            return null;\n        }\n        let lit_end = this.ind;\n        this.advance();\n        let value = this.source.substring(lit_start, lit_end);\n        return new StringLiteral(value);\n    }\n    number() {\n        let start = this.ind - 1;\n        while (this.is_digit_(this.peek())) {\n            this.advance();\n        }\n        if (this.peek() == '.' && this.is_digit_(this.double_peek())) {\n            this.advance();\n            while (this.is_digit_(this.peek()))\n                this.advance();\n        }\n        return new NumberLiteral(parseFloat(this.source.substring(start, this.ind)));\n    }\n    identifier() {\n        let start = this.ind - 1;\n        while (this.is_alphanumeric_(this.peek())) {\n            this.advance();\n        }\n        let str = this.source.substring(start, this.ind);\n        switch (str) {\n            case \"and\": return new And();\n            case \"class\": return new Class();\n            case \"else\": return new Else();\n            case \"false\": return new BoolLiteral(false);\n            case \"for\": return new For();\n            case \"fun\": return new Fun();\n            case \"if\": return new If();\n            case \"nil\": return new Nil();\n            case \"or\": return new Or();\n            case \"print\": return new Print();\n            case \"return\": return new Return();\n            case \"super\": return new Super();\n            case \"this\": return new This();\n            case \"true\": return new BoolLiteral(true);\n            case \"var\": return new Var();\n            case \"while\": return new While();\n            default: return new Identifier(str);\n        }\n    }\n    is_digit(x) {\n        return /\\d/.test(x);\n    }\n    is_digit_(x) {\n        if (x == null) {\n            return false;\n        }\n        return /\\d/.test(x);\n    }\n    is_alpha(x) {\n        return /[a-zA-Z]/.test(x);\n    }\n    is_alphanumeric(x) {\n        return this.is_digit(x) || this.is_alpha(x);\n    }\n    is_alphanumeric_(x) {\n        if (x == null) {\n            return false;\n        }\n        return this.is_digit(x) || this.is_alpha(x);\n    }\n    at_end() {\n        return this.ind >= this.source.length;\n    }\n    peek() {\n        if (this.at_end()) {\n            return null;\n        }\n        else {\n            return this.source[this.ind];\n        }\n    }\n    double_peek() {\n        if (this.ind + 1 >= this.source.length) {\n            return null;\n        }\n        else {\n            return this.source[this.ind + 1];\n        }\n    }\n    advance() {\n        if (this.at_end()) {\n            return null;\n        }\n        else {\n            return this.source[this.ind++];\n        }\n    }\n    match(x) {\n        if (this.peek() == x) {\n            this.advance();\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    span(start) {\n        return new diagnostics.Span(this.source, start, this.ind);\n    }\n}\nfunction lex(input) {\n    return new Lexer(input).lex();\n}\nexports.lex = lex;\n\n\n//# sourceURL=webpack://thing/./build/ts/lexer.js?");

/***/ }),

/***/ "./build/ts/main.js":
/*!**************************!*\
  !*** ./build/ts/main.js ***!
  \**************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst diagnostics = __importStar(__webpack_require__(/*! ./diagnostics */ \"./build/ts/diagnostics.js\"));\nconst bytecode = __importStar(__webpack_require__(/*! ./bytecode */ \"./build/ts/bytecode.js\"));\nconst lexer = __importStar(__webpack_require__(/*! ./lexer */ \"./build/ts/lexer.js\"));\nconst parser = __importStar(__webpack_require__(/*! ./parser */ \"./build/ts/parser.js\"));\nconst compiler = __importStar(__webpack_require__(/*! ./compiler */ \"./build/ts/compiler.js\"));\nconst vm = __importStar(__webpack_require__(/*! ./vm */ \"./build/ts/vm.js\"));\nlet editor = ace.edit(\"codeeditor\");\neditor.setOption(\"printMarginColumn\", false);\ndocument.getElementById('submitbutton').addEventListener('click', function () {\n    let inputcodebox = document.getElementById('inputcodebox');\n    let input = editor.getValue();\n    diagnostics.clear();\n    let lexed = lexer.lex(input);\n    let parsed = parser.parse(lexed);\n    if (parsed) {\n        let compiled = compiler.compile(parsed);\n        vm.interpret(compiled);\n        let ppc = new bytecode.PrettyPrintContext();\n        ppc.pretty_print_instrs(compiled);\n        document.getElementById('compiledcodeview').textContent = ppc.result;\n        console.log(compiled);\n        console.log(ppc.result);\n    }\n});\n\n\n//# sourceURL=webpack://thing/./build/ts/main.js?");

/***/ }),

/***/ "./build/ts/parser.js":
/*!****************************!*\
  !*** ./build/ts/parser.js ***!
  \****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parse = void 0;\nconst lexer = __importStar(__webpack_require__(/*! ./lexer */ \"./build/ts/lexer.js\"));\nconst diagnostics = __importStar(__webpack_require__(/*! ./diagnostics */ \"./build/ts/diagnostics.js\"));\nconst ast = __importStar(__webpack_require__(/*! ./ast */ \"./build/ts/ast.js\"));\nconst peg = __importStar(__webpack_require__(/*! ./peg */ \"./build/ts/peg.js\"));\nfunction astify_binary_expr([comp, ops]) {\n    let cur;\n    while (cur = ops.shift()) {\n        let [op, right] = cur;\n        let op_ast;\n        switch (op.type) {\n            case \"'+'\":\n                op_ast = ast.BinaryOperator.Plus;\n                break;\n            case \"'-'\":\n                op_ast = ast.BinaryOperator.Minus;\n                break;\n            case \"'*'\":\n                op_ast = ast.BinaryOperator.Star;\n                break;\n            case \"'/'\":\n                op_ast = ast.BinaryOperator.Slash;\n                break;\n            case \"'<'\":\n                op_ast = ast.BinaryOperator.Less;\n                break;\n            case \"'>'\":\n                op_ast = ast.BinaryOperator.Greater;\n                break;\n            case \"'<='\":\n                op_ast = ast.BinaryOperator.LessEqual;\n                break;\n            case \"'=='\":\n                op_ast = ast.BinaryOperator.EqualEqual;\n                break;\n            case \"'>='\":\n                op_ast = ast.BinaryOperator.GreaterEqual;\n                break;\n            case \"'!='\":\n                op_ast = ast.BinaryOperator.BangEqual;\n                break;\n            default: throw Error('unreachable');\n        }\n        comp = new ast.BinaryExpr(diagnostics.join_spans(comp.span, right.span), comp, right, op_ast);\n    }\n    return comp;\n}\nlet block;\nlet expression;\nlet expression_indirect = () => expression;\nlet args = new peg.Indirect(expression_indirect).chain(new peg.ZeroMore(new peg.Token(\"','\").chain(new peg.Indirect(expression_indirect)))).apply(([first, more]) => [first].concat(more.map(x => x[1])));\nlet params = new peg.Token(\"identifier\").chain(new peg.ZeroMore(new peg.Token(\"','\").chain(new peg.Token(\"identifier\")))).apply(([first, more]) => [first].concat(more.map(x => x[1])));\nlet fn = new peg.Token(\"identifier\").chain(new peg.Token(\"'('\")).chain(new peg.Optional(params)).chain(new peg.Token(\"')'\")).chain(new peg.Indirect(() => block))\n    .apply(([[[[identifier, oparen], params], cparen], block]) => [identifier, params ? params : [], block]);\nlet primary = new peg.Token('bool literal').apply(tok => new ast.BoolLiteral(tok.span, tok.bool)).choice(new peg.Token(\"'nil'\").apply(tok => new ast.NilLiteral(tok.span))).choice(new peg.Token('number literal').apply(tok => new ast.NumberLiteral(tok.span, tok.num))).choice(new peg.Token('string literal').apply(tok => new ast.StringLiteral(tok.span, tok.str))).choice(new peg.Token(\"identifier\").apply(ident => new ast.VarExpr(ident.span, ident.name))).choice(new peg.Token(\"'('\").chain(new peg.Indirect(expression_indirect)).chain(new peg.Token(\"')'\")).apply(([[oparen, expr], cparen]) => expr));\nlet call = primary.chain(new peg.ZeroMore(new peg.Choice(new peg.Token(\"'('\").chain(new peg.Optional(args)).chain(new peg.Token(\"')'\")).apply(([[oparen, args], cparen]) => { let x = [args, cparen]; return x; }), new peg.Token(\"'.'\").chain(new peg.Token(\"identifier\")).apply(([dot, ident]) => ident)))).apply(([expr, ops]) => {\n    let cur_op;\n    while (cur_op = ops.shift()) {\n        if (cur_op instanceof lexer.Identifier) {\n            let ident = cur_op;\n            // expr =\n            throw new Error(\"not implemented yet\"); // TODO\n        }\n        else {\n            let a;\n            if (cur_op[0]) {\n                a = cur_op[0];\n            }\n            else {\n                a = [];\n            }\n            expr = new ast.CallExpr(diagnostics.join_spans(expr.span, cur_op[1].span), expr, a);\n        }\n    }\n    return expr;\n});\nlet unary;\nunary =\n    (new peg.Token(\"'-'\").choice(new peg.Token(\"'!'\"))).chain(new peg.Indirect(() => unary)).apply(([op, expr]) => {\n        let op_ast;\n        switch (op.type) {\n            case \"'-'\":\n                op_ast = ast.UnaryOperator.Minus;\n                break;\n            case \"'!'\":\n                op_ast = ast.UnaryOperator.Bang;\n                break;\n            default: throw Error('unreachable');\n        }\n        return new ast.UnaryExpr(diagnostics.join_spans(op.span, expr.span), op_ast, expr);\n    })\n        .choice(call);\nlet factor = new peg.Apply(astify_binary_expr, new peg.Chain(unary, new peg.ZeroMore(new peg.Chain(new peg.Choice(new peg.Token(\"'*'\"), new peg.Token(\"'/'\")), unary))));\nlet term = new peg.Apply(astify_binary_expr, new peg.Chain(factor, new peg.ZeroMore(new peg.Chain(new peg.Choice(new peg.Token(\"'+'\"), new peg.Token(\"'-'\")), factor))));\nlet comparison = new peg.Apply(astify_binary_expr, new peg.Chain(term, new peg.ZeroMore(new peg.Chain(new peg.Choice(new peg.Choice(new peg.Choice(new peg.Token(\"'<'\"), new peg.Token(\"'<='\")), new peg.Token(\"'>'\")), new peg.Token(\"'>='\")), term))));\nlet equality = new peg.Apply(astify_binary_expr, new peg.Chain(comparison, new peg.ZeroMore(new peg.Chain(new peg.Choice(new peg.Token(\"'=='\"), new peg.Token(\"'!='\")), comparison))));\nlet logic_and = equality.chain(new peg.ZeroMore(new peg.Token(\"'and'\").chain(equality))).apply(astify_binary_expr);\nlet logic_or = logic_and.chain(new peg.ZeroMore(new peg.Token(\"'or'\").chain(logic_and))).apply(astify_binary_expr);\nlet assignment;\nassignment =\n    new peg.Optional(call.chain(new peg.Token(\"'.'\"))).chain(new peg.Token(\"identifier\")).chain(new peg.Token(\"'='\")).chain(new peg.Indirect(() => assignment))\n        .apply(([[[m_call, ident], eq], assignment]) => new ast.AssignExpr(diagnostics.join_spans(m_call ? m_call[0].span : ident.span, assignment.span), ident.name, assignment))\n        .choice(logic_or);\nexpression = assignment;\nlet expr_stmt = new peg.Apply(([expr, semi]) => new ast.ExprStmt(diagnostics.join_spans(expr.span, semi.span), expr), new peg.Chain(new peg.Indirect(expression_indirect), new peg.Token(\"';'\")));\nlet print_stmt = new peg.Apply(([[print, expr], semi]) => new ast.PrintStmt(diagnostics.join_spans(print.span, semi.span), expr), new peg.Chain(new peg.Chain(new peg.Token(\"'print'\"), new peg.Indirect(expression_indirect)), new peg.Token(\"';'\")));\nlet var_decl;\nlet statement;\nlet statement_indirect = () => statement;\nlet declaration;\nlet declaration_indirect = () => declaration;\nlet for_stmt = new peg.Chain(new peg.Chain(new peg.Chain(new peg.Chain(new peg.Chain(new peg.Chain(new peg.Token(\"'for'\"), new peg.Token(\"'('\")), new peg.Choice(new peg.Choice(new peg.Indirect(() => var_decl), expr_stmt), new peg.Token(\"';'\").apply(() => null))), new peg.Chain(new peg.Optional(new peg.Indirect(expression_indirect)), new peg.Token(\"';'\"))), new peg.Optional(new peg.Indirect(expression_indirect))), new peg.Token(\"')'\")), new peg.Indirect(statement_indirect))\n    .apply(([[[[[[for_, oparen], initializer], cond], inc], cparen], body]) => {\n    return new ast.ForStmt(diagnostics.join_spans(for_.span, body.span), initializer, cond[0], inc, body, for_.span);\n});\nlet if_stmt = new peg.Apply(([[[[[if_, oparen], cond], cparen], body], m_else]) => new ast.IfStmt(diagnostics.join_spans(if_.span, m_else ? m_else[1].span : body.span), cond, body, m_else ? m_else[1] : null), new peg.Chain(new peg.Chain(new peg.Chain(new peg.Chain(new peg.Chain(new peg.Token(\"'if'\"), new peg.Token(\"'('\")), new peg.Indirect(expression_indirect)), new peg.Token(\"')'\")), new peg.Indirect(statement_indirect)), new peg.Optional(new peg.Chain(new peg.Token(\"'else'\"), new peg.Indirect(statement_indirect)))));\nlet return_stmt = new peg.Apply(([[return_, m_expr], semi]) => new ast.ReturnStmt(diagnostics.join_spans(return_.span, semi.span), m_expr), new peg.Chain(new peg.Chain(new peg.Token(\"'return'\"), new peg.Optional(new peg.Indirect(expression_indirect))), new peg.Token(\"';'\")));\nlet while_stmt = new peg.Apply(([[[[while_, oparen], cond], cparen], body]) => new ast.WhileStmt(diagnostics.join_spans(while_.span, body.span), cond, body), new peg.Chain(new peg.Chain(new peg.Chain(new peg.Chain(new peg.Token(\"'while'\"), new peg.Token(\"'('\")), new peg.Indirect(expression_indirect)), new peg.Token(\"')'\")), new peg.Indirect(statement_indirect)));\nblock =\n    new peg.Apply(([[obrace, decls], cbrace]) => new ast.BlockStmt(diagnostics.join_spans(obrace.span, cbrace.span), decls, obrace.span, cbrace.span), new peg.Chain(new peg.Chain(new peg.Token(\"'{'\"), new peg.ZeroMore(new peg.Indirect(declaration_indirect))), new peg.Token(\"'}'\")));\nstatement =\n    expr_stmt\n        .choice(print_stmt)\n        .choice(for_stmt)\n        .choice(if_stmt)\n        .choice(return_stmt)\n        .choice(while_stmt)\n        .choice(block);\nvar_decl =\n    new peg.Apply(([[[var_, ident], m_initializer], semi]) => new ast.VarStmt(diagnostics.join_spans(var_.span, semi.span), ident.name, m_initializer ? m_initializer[1] : null), new peg.Chain(new peg.Chain(new peg.Chain(new peg.Token(\"'var'\"), new peg.Token(\"identifier\")), new peg.Optional(new peg.Chain(new peg.Token(\"'='\"), new peg.Indirect(expression_indirect)))), new peg.Token(\"';'\")));\nlet fun_decl = new peg.Chain(new peg.Token(\"'fun'\"), fn).apply(([fun, [identifier, params, block]]) => new ast.FunctionStmt(diagnostics.join_spans(fun.span, block.span), identifier.name, params.map(x => x.name), block));\ndeclaration = new peg.Choice(new peg.Choice(fun_decl, var_decl), statement);\nlet script = new peg.Apply(([stmts, eof]) => stmts, new peg.Chain(new peg.ZeroMore(declaration), new peg.Token(\"eof\")));\nfunction parse([tokens, eof]) {\n    let parser = new peg.Parser(tokens, eof);\n    let location = new peg.ParseLocation(parser, 0);\n    let res = script.parse(parser, location);\n    if (res) {\n        return res[1];\n    }\n    else {\n        parser.report_error();\n        return null;\n    }\n}\nexports.parse = parse;\n\n\n//# sourceURL=webpack://thing/./build/ts/parser.js?");

/***/ }),

/***/ "./build/ts/peg.js":
/*!*************************!*\
  !*** ./build/ts/peg.js ***!
  \*************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Indirect = exports.Apply = exports.OneMore = exports.ZeroMore = exports.Optional = exports.Choice = exports.Chain = exports.Token = exports.PEG = exports.ParseLocation = exports.Parser = void 0;\nconst diagnostics = __importStar(__webpack_require__(/*! ./diagnostics */ \"./build/ts/diagnostics.js\"));\nclass Parser {\n    constructor(tokens, eof) {\n        this.tokens = tokens;\n        this.eof = eof;\n        this.errors = new Map();\n    }\n    error(ind, expect) {\n        if (!this.errors.has(ind)) {\n            this.errors.set(ind, []);\n        }\n        this.errors.get(ind).push(expect);\n    }\n    report_error() {\n        let max_ind = Math.max(...this.errors.keys());\n        let got = this.get_tok(max_ind);\n        let es = this.errors.get(max_ind);\n        let explanation;\n        if (es.length == 1) {\n            explanation = `expected ${es[0]}, got ${got.type}`;\n        }\n        else {\n            explanation = `expected one of ${es}, got ${got.type}`;\n        }\n        diagnostics.report({\n            message: `parse error: ${explanation}`,\n            explanation: null,\n            span: got.span,\n        });\n    }\n    get_tok(ind) {\n        if (ind >= this.tokens.length) {\n            return this.eof;\n        }\n        else {\n            return this.tokens[ind];\n        }\n    }\n}\nexports.Parser = Parser;\nclass ParseLocation {\n    constructor(parser, ind) {\n        this.parser = parser;\n        this.ind = ind;\n    }\n    advance() {\n        return new ParseLocation(this.parser, this.ind + 1);\n    }\n    tok() { return this.parser.get_tok(this.ind); }\n}\nexports.ParseLocation = ParseLocation;\nclass PEG {\n    // convenience methods\n    chain(other) {\n        return new Chain(this, other);\n    }\n    choice(other) {\n        return new Choice(this, other);\n    }\n    apply(op) {\n        return new Apply(op, this);\n    }\n}\nexports.PEG = PEG;\nclass Token extends PEG {\n    constructor(type) {\n        super();\n        this.type = type;\n    }\n    parse(parser, location) {\n        let t = location.tok();\n        if (t.type == this.type) {\n            return [location.advance(), t];\n        }\n        else {\n            parser.error(location.ind, this.type);\n            return null;\n        }\n    }\n}\nexports.Token = Token;\nclass Chain extends PEG {\n    constructor(a, b) {\n        super();\n        this.a = a;\n        this.b = b;\n    }\n    parse(parser, location) {\n        let m_a_res = this.a.parse(parser, location);\n        if (m_a_res) {\n            let [location_, a_res] = m_a_res;\n            let m_b_res = this.b.parse(parser, location_);\n            if (m_b_res) {\n                let [location__, b_res] = m_b_res;\n                return [location__, [a_res, b_res]];\n            }\n        }\n        return null;\n    }\n}\nexports.Chain = Chain;\nclass Choice extends PEG {\n    constructor(a, b) {\n        super();\n        this.a = a;\n        this.b = b;\n    }\n    parse(parser, location) {\n        let m_a_res = this.a.parse(parser, location);\n        if (m_a_res) {\n            return m_a_res;\n        }\n        else {\n            let m_b_res = this.b.parse(parser, location);\n            if (m_b_res) {\n                return m_b_res;\n            }\n        }\n        return null;\n    }\n}\nexports.Choice = Choice;\nclass Optional extends PEG {\n    constructor(a) {\n        super();\n        this.a = a;\n    }\n    parse(parser, location) {\n        let m_a_res = this.a.parse(parser, location);\n        if (m_a_res) {\n            let [location_, a_res] = m_a_res;\n            return [location_, a_res];\n        }\n        else {\n            return [location, null];\n        }\n    }\n}\nexports.Optional = Optional;\nclass ZeroMore extends PEG {\n    constructor(a) {\n        super();\n        this.a = a;\n    }\n    parse(parser, location) {\n        let items = [];\n        while (true) {\n            let m_res = this.a.parse(parser, location);\n            if (m_res) {\n                let [location_, item] = m_res;\n                location = location_;\n                items.push(item);\n            }\n            else {\n                return [location, items];\n            }\n        }\n    }\n}\nexports.ZeroMore = ZeroMore;\nclass OneMore extends PEG {\n    constructor(a) {\n        super();\n        this.a = a;\n    }\n    parse(parser, location) {\n        return new Apply(([first, more]) => [first].concat(more), new Chain(this.a, new ZeroMore(this.a))).parse(parser, location);\n    }\n}\nexports.OneMore = OneMore;\nclass Apply extends PEG {\n    constructor(op, a) {\n        super();\n        this.op = op;\n        this.a = a;\n    }\n    parse(parser, location) {\n        let m_a_res = this.a.parse(parser, location);\n        if (m_a_res) {\n            let [location_, a_res] = m_a_res;\n            let b_res = this.op(a_res);\n            return [location_, b_res];\n        }\n        return null;\n    }\n}\nexports.Apply = Apply;\nclass Indirect extends PEG {\n    constructor(thing) {\n        super();\n        this.thing = thing;\n    }\n    parse(parser, location) {\n        return this.thing().parse(parser, location);\n    }\n}\nexports.Indirect = Indirect;\n\n\n//# sourceURL=webpack://thing/./build/ts/peg.js?");

/***/ }),

/***/ "./build/ts/vm.js":
/*!************************!*\
  !*** ./build/ts/vm.js ***!
  \************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.interpret = void 0;\nfunction interpret(instructions) {\n    let registers = [];\n    let variables = [new Map()];\n    for (let instr of instructions) {\n    }\n}\nexports.interpret = interpret;\n\n\n//# sourceURL=webpack://thing/./build/ts/vm.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./build/ts/main.js");
/******/ 	
/******/ })()
;
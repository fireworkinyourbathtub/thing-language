/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./build/ts/ast.js":
/*!*************************!*\
  !*** ./build/ts/ast.js ***!
  \*************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LogicalOperator = exports.UnaryOperator = exports.BinaryOperator = void 0;\n// | ClassStmt\nvar BinaryOperator;\n(function (BinaryOperator) {\n    BinaryOperator[BinaryOperator[\"Plus\"] = 0] = \"Plus\";\n    BinaryOperator[BinaryOperator[\"Minus\"] = 1] = \"Minus\";\n    BinaryOperator[BinaryOperator[\"Star\"] = 2] = \"Star\";\n    BinaryOperator[BinaryOperator[\"Slash\"] = 3] = \"Slash\";\n    BinaryOperator[BinaryOperator[\"Less\"] = 4] = \"Less\";\n    BinaryOperator[BinaryOperator[\"Greater\"] = 5] = \"Greater\";\n    BinaryOperator[BinaryOperator[\"LessEqual\"] = 6] = \"LessEqual\";\n    BinaryOperator[BinaryOperator[\"GreaterEqual\"] = 7] = \"GreaterEqual\";\n    BinaryOperator[BinaryOperator[\"EqualEqual\"] = 8] = \"EqualEqual\";\n    BinaryOperator[BinaryOperator[\"BangEqual\"] = 9] = \"BangEqual\";\n})(BinaryOperator = exports.BinaryOperator || (exports.BinaryOperator = {}));\nvar UnaryOperator;\n(function (UnaryOperator) {\n    UnaryOperator[UnaryOperator[\"Minus\"] = 0] = \"Minus\";\n    UnaryOperator[UnaryOperator[\"Bang\"] = 1] = \"Bang\";\n})(UnaryOperator = exports.UnaryOperator || (exports.UnaryOperator = {}));\nvar LogicalOperator;\n(function (LogicalOperator) {\n    LogicalOperator[LogicalOperator[\"And\"] = 0] = \"And\";\n    LogicalOperator[LogicalOperator[\"Or\"] = 1] = \"Or\";\n})(LogicalOperator = exports.LogicalOperator || (exports.LogicalOperator = {}));\n\n\n//# sourceURL=webpack://thing/./build/ts/ast.js?");

/***/ }),

/***/ "./build/ts/bytecode.js":
/*!******************************!*\
  !*** ./build/ts/bytecode.js ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.pretty_print = void 0;\nconst diagnostics = __importStar(__webpack_require__(/*! ./diagnostics */ \"./build/ts/diagnostics.js\"));\nconst ast = __importStar(__webpack_require__(/*! ./ast */ \"./build/ts/ast.js\"));\nfunction pretty_print(instrs) {\n    let indentation = 0;\n    let result = '';\n    let cur_number = 0;\n    let mapping = new Map();\n    function blank_line() {\n        result += '\\n';\n    }\n    function append(instr, s, sp) {\n        let sp_contents = sp.contents;\n        let sp_annotation = sp_contents.split('\\n').length > 1 ? `${sp_contents.split('\\n')[0]}...` : sp_contents;\n        append_no_span(instr, `${s}${' '.repeat(40 - s.length)}// ${sp_annotation}`);\n    }\n    function append_no_span(instr, s) {\n        let append = `${' '.repeat(indentation * 4)}${s}\\n`;\n        if (instr != undefined)\n            mapping.set(instr, [result.length, result.length + append.length]);\n        result += append;\n    }\n    function append_marker(instr, s) {\n        blank_line();\n        append_no_span(instr, s);\n    }\n    function pp_instrs(instrs) {\n        for (let instr of instrs) {\n            pp_instr(instr);\n        }\n    }\n    function pp_instr(instr) {\n        switch (instr.type) {\n            case 'Print': {\n                append(instr, `print ${instr.value.pretty_print()};`, instr.span);\n                break;\n            }\n            case 'MakeVar': {\n                append(instr, `make_var ${instr.name} = ${instr.value.pretty_print()};`, instr.span);\n                break;\n            }\n            case 'While': {\n                append(instr, 'while {', instr.span);\n                indent();\n                pp_instrs(instr.check_code);\n                append_no_span(undefined, `check ${instr.check.pretty_print()}`);\n                dedent();\n                append_no_span(undefined, '}');\n                append_no_span(undefined, '{');\n                indent();\n                pp_instrs(instr.body_code);\n                dedent();\n                append_no_span(undefined, '}');\n                break;\n            }\n            case 'If': {\n                append(instr, `if ${instr.cond.pretty_print()} {`, instr.span);\n                indent();\n                pp_instrs(instr.true_branch);\n                dedent();\n                if (instr.false_branch) {\n                    append_no_span(instr, '} else {');\n                    indent();\n                    pp_instrs(instr.false_branch);\n                    dedent();\n                    append_no_span(instr, '}');\n                }\n                else {\n                    append_no_span(instr, '}');\n                }\n                break;\n            }\n            case 'Return': {\n                append(instr, `return ${instr.value.pretty_print()};`, instr.span);\n                break;\n            }\n            case 'StartScope': {\n                append(instr, `start_scope;`, instr.span);\n                break;\n            }\n            case 'EndScope': {\n                append(instr, `end_scope;`, instr.span);\n                break;\n            }\n            case 'ReadVar': {\n                append(instr, `read_var ${instr.name} -> ${instr.dest.pretty_print()};`, instr.span);\n                break;\n            }\n            case 'Assign': {\n                append(instr, `assign ${instr.name} = ${instr.value.pretty_print()};`, instr.span);\n                break;\n            }\n            case 'Call': {\n                append(instr, `call ${instr.callee.pretty_print()}(${instr.args.map(a => a.pretty_print()).join()}) -> ${instr.dest.pretty_print()};`, instr.span);\n                break;\n            }\n            case 'BinaryOp': {\n                let op_name;\n                switch (instr.op) {\n                    case ast.BinaryOperator.Plus:\n                        op_name = 'add';\n                        break;\n                    case ast.BinaryOperator.Minus:\n                        op_name = 'sub';\n                        break;\n                    case ast.BinaryOperator.Star:\n                        op_name = 'mul';\n                        break;\n                    case ast.BinaryOperator.Slash:\n                        op_name = 'div';\n                        break;\n                    case ast.BinaryOperator.Less:\n                        op_name = 'cmp<';\n                        break;\n                    case ast.BinaryOperator.Greater:\n                        op_name = 'cmp>';\n                        break;\n                    case ast.BinaryOperator.LessEqual:\n                        op_name = 'cmp<=';\n                        break;\n                    case ast.BinaryOperator.EqualEqual:\n                        op_name = 'cmp==';\n                        break;\n                    case ast.BinaryOperator.GreaterEqual:\n                        op_name = 'cmp>=';\n                        break;\n                    case ast.BinaryOperator.BangEqual:\n                        op_name = 'cmp!=';\n                        break;\n                }\n                append(instr, `${op_name} ${instr.l.pretty_print()} ${instr.r.pretty_print()} -> ${instr.dest.pretty_print()};`, instr.span);\n                break;\n            }\n            case 'UnaryOp': {\n                let op_name;\n                switch (instr.op) {\n                    case ast.UnaryOperator.Minus:\n                        op_name = 'neg';\n                        break;\n                    case ast.UnaryOperator.Bang:\n                        op_name = 'logic_neg';\n                        break;\n                }\n                append(instr, `${op_name} ${instr.v.pretty_print()} -> ${instr.dest.pretty_print()};`, instr.span);\n                break;\n            }\n            case 'StmtMarker': {\n                append_marker(instr, `// line ${instr.span.start_line}: ${diagnostics.get_line(instr.span.source, instr.span.start_line)}`);\n                break;\n            }\n        }\n    }\n    function indent() {\n        ++indentation;\n    }\n    function dedent() {\n        --indentation;\n    }\n    pp_instrs(instrs);\n    return [result, mapping];\n}\nexports.pretty_print = pretty_print;\n\n\n//# sourceURL=webpack://thing/./build/ts/bytecode.js?");

/***/ }),

/***/ "./build/ts/compiler.js":
/*!******************************!*\
  !*** ./build/ts/compiler.js ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.compile = void 0;\nconst runtime = __importStar(__webpack_require__(/*! ./runtime */ \"./build/ts/runtime.js\"));\nclass RegisterContext {\n    constructor() {\n        this.register_i = 0;\n    }\n    new_register() {\n        return new runtime.Register(this.register_i++);\n    }\n}\nfunction make_stmt_marker(stmt) {\n    return { type: 'StmtMarker', span: stmt.span };\n}\nfunction compile(stmts) {\n    let register_context = new RegisterContext();\n    let instructions = [];\n    for (let stmt of stmts) {\n        compile_stmt(stmt, instructions, register_context);\n    }\n    return instructions;\n}\nexports.compile = compile;\nfunction compile_stmt(stmt, instructions, register_context) {\n    instructions.push(make_stmt_marker(stmt));\n    switch (stmt.type) {\n        case 'ExprStmt': {\n            compile_expr(stmt.expr, instructions, register_context);\n            break;\n        }\n        case 'PrintStmt': {\n            let e = compile_expr(stmt.expr, instructions, register_context);\n            instructions.push({ type: 'Print', span: stmt.span, value: e });\n            break;\n        }\n        case 'VarStmt': {\n            let e;\n            if (stmt.initializer) {\n                e = compile_expr(stmt.initializer, instructions, register_context);\n            }\n            else {\n                e = new runtime.Nil();\n            }\n            instructions.push({ type: 'MakeVar', span: stmt.span, name: stmt.name, value: e });\n            break;\n        }\n        case 'BlockStmt': {\n            instructions.push({ type: 'StartScope', span: stmt.obrace_sp });\n            for (let sub_stmt of stmt.stmts) {\n                compile_stmt(sub_stmt, instructions, register_context);\n            }\n            instructions.push({ type: 'EndScope', span: stmt.cbrace_sp });\n            break;\n        }\n        case 'FunctionStmt': {\n            let register_context = new RegisterContext();\n            let instrs = [];\n            compile_stmt(stmt.body, instrs, register_context);\n            let fn = new runtime.Function(stmt.name, stmt.params, instrs);\n            instructions.push({ type: 'MakeVar', span: stmt.span, name: stmt.name, value: fn });\n            break;\n        }\n        case 'ForStmt': {\n            instructions.push({ type: 'StartScope', span: stmt.for_sp });\n            if (stmt.initializer) {\n                compile_stmt(stmt.initializer, instructions, register_context);\n            }\n            let check_code = [];\n            let check;\n            if (stmt.compare) {\n                check = compile_expr(stmt.compare, check_code, register_context);\n            }\n            else {\n                check = new runtime.Bool(true);\n            }\n            let body_code = [];\n            compile_stmt(stmt.body, body_code, register_context);\n            if (stmt.increment) {\n                compile_expr(stmt.increment, body_code, register_context);\n            }\n            instructions.push({ type: 'While', span: stmt.span, check_code, check, body_code });\n            instructions.push({ type: 'EndScope', span: stmt.for_sp }); // TODO: better span?\n            break;\n        }\n        case 'IfStmt': {\n            let cond = compile_expr(stmt.condition, instructions, register_context);\n            let true_code = [];\n            compile_stmt(stmt.then_branch, true_code, register_context);\n            let false_code;\n            if (stmt.else_branch) {\n                false_code = [];\n                compile_stmt(stmt.else_branch, false_code, register_context);\n            }\n            else {\n                false_code = null;\n            }\n            instructions.push({ type: 'If', span: stmt.span, cond, true_branch: true_code, false_branch: false_code });\n            break;\n        }\n        case 'ReturnStmt': {\n            let e;\n            if (stmt.value) {\n                e = compile_expr(stmt.value, instructions, register_context);\n            }\n            else {\n                e = new runtime.Nil();\n            }\n            instructions.push({ type: 'Return', span: stmt.span, value: e });\n            break;\n        }\n        case 'WhileStmt': {\n            let check_code = [];\n            let check = compile_expr(stmt.condition, check_code, register_context);\n            let body_code = [];\n            compile_stmt(stmt.body, body_code, register_context);\n            instructions.push({ type: 'While', span: stmt.span, check_code, check, body_code });\n            break;\n        }\n    }\n}\nfunction compile_expr(expr, instructions, register_context) {\n    switch (expr.type) {\n        case 'BinaryExpr': {\n            let l = compile_expr(expr.left, instructions, register_context);\n            let r = compile_expr(expr.right, instructions, register_context);\n            let reg = register_context.new_register();\n            instructions.push({ type: 'BinaryOp', span: expr.span, l, r, op: expr.op, dest: reg });\n            return reg;\n        }\n        case 'UnaryExpr': {\n            let v = compile_expr(expr.operand, instructions, register_context);\n            let reg = register_context.new_register();\n            instructions.push({ type: 'UnaryOp', span: expr.span, v, op: expr.operator, dest: reg });\n            return reg;\n        }\n        case 'VarExpr': {\n            let reg = register_context.new_register();\n            instructions.push({ type: 'ReadVar', span: expr.span, name: expr.name, dest: reg });\n            return reg;\n        }\n        case 'StringLiteral': {\n            return new runtime.String(expr.value);\n        }\n        case 'NumberLiteral': {\n            return new runtime.Number(expr.value);\n        }\n        case 'BoolLiteral': {\n            return new runtime.Bool(expr.value);\n        }\n        case 'NilLiteral': {\n            return new runtime.Nil();\n        }\n        case 'AssignExpr': {\n            let value = compile_expr(expr.value, instructions, register_context);\n            instructions.push({ type: 'Assign', span: expr.span, name: expr.name, value });\n            return value;\n        }\n        case 'CallExpr': {\n            let callee = compile_expr(expr.callee, instructions, register_context);\n            let args = [];\n            for (let a_ast of expr.args) {\n                args.push(compile_expr(a_ast, instructions, register_context));\n            }\n            let reg = register_context.new_register();\n            instructions.push({ type: 'Call', span: expr.span, callee, args, dest: reg });\n            return reg;\n        }\n        case 'LogicalExpr': {\n            throw new Error(\"not implemented yet\"); // TODO\n        }\n    }\n}\n\n\n//# sourceURL=webpack://thing/./build/ts/compiler.js?");

/***/ }),

/***/ "./build/ts/diagnostics.js":
/*!*********************************!*\
  !*** ./build/ts/diagnostics.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.report = exports.join_spans = exports.clear = exports.get_line = exports.Span = void 0;\nconst errors_div = document.getElementById('errors');\nclass Span {\n    constructor(source, start, end) {\n        this.source = source;\n        this.start = start;\n        this.end = end;\n        [this.start_line, this.start_column] = get_linecol(source, start);\n        [this.end_line, this.end_column] = get_linecol(source, end);\n        this.contents = source.substring(start, end);\n    }\n}\nexports.Span = Span;\nfunction get_linecol(source, ind) {\n    let line = (source.substring(0, ind).match(/^/mg) || []).length;\n    let lines = source.substring(0, ind).match(/^.+/mg);\n    if (lines) {\n        return [line, lines[lines.length - 1].length + 1];\n    }\n    else {\n        return [line, 0];\n    }\n}\nfunction get_line(source, line) {\n    return source.split('\\n')[line - 1];\n}\nexports.get_line = get_line;\nfunction clear() {\n    while (errors_div.lastChild) {\n        errors_div.removeChild(errors_div.lastChild);\n    }\n}\nexports.clear = clear;\nfunction join_spans(sp1, sp2) {\n    return new Span(sp1.source, Math.min(sp1.start, sp2.start), Math.max(sp1.end, sp2.end));\n}\nexports.join_spans = join_spans;\nfunction report(diagnostic) {\n    let div = document.createElement('div');\n    div.className = 'error';\n    {\n        let heading = document.createElement('p');\n        heading.className = 'error_heading';\n        heading.innerHTML = `error at ${diagnostic.span.start_line}:${diagnostic.span.start_column}: ${diagnostic.message}`;\n        div.appendChild(heading);\n    }\n    {\n        function make_line_view(source, nr, highlight_start_col, highlight_end_col) {\n            let line_view = document.createElement('div');\n            line_view.className = 'error_line_view';\n            let line_number = document.createElement('p');\n            line_number.innerHTML = nr.toString();\n            line_number.className = 'error_linenumber';\n            let pre = document.createElement('pre');\n            let code = document.createElement('code');\n            pre.className = 'error_pre';\n            code.className = 'error_code';\n            if (highlight_start_col == null || highlight_end_col == null) {\n                code.innerHTML = source[nr - 1];\n            }\n            else {\n                let line_contents = source[nr - 1];\n                let start = highlight_start_col - 1;\n                let end = highlight_end_col == -1 ? line_contents.length : highlight_end_col - 1;\n                code.innerHTML = `${line_contents.substring(0, start)}<strong>${line_contents.substring(start, end)}</strong>${line_contents.substring(end)}`;\n            }\n            line_view.appendChild(line_number);\n            pre.appendChild(code);\n            line_view.appendChild(pre);\n            return line_view;\n        }\n        let view = document.createElement('div');\n        view.className = 'error_view';\n        let source_lines = diagnostic.span.source.split('\\n');\n        for (let i = diagnostic.span.start_line; i <= diagnostic.span.end_line; ++i) {\n            let highlight_start_col = diagnostic.span.start_line == i ? diagnostic.span.start_column :\n                diagnostic.span.start_line < i ? 0 : null;\n            let highlight_end_col = diagnostic.span.end_line == i ? diagnostic.span.end_column :\n                diagnostic.span.end_line < i ? null : -1;\n            view.appendChild(make_line_view(source_lines, i, highlight_start_col, highlight_end_col));\n        }\n        div.appendChild(view);\n    }\n    if (diagnostic.explanation) {\n        let explanation = document.createElement('p');\n        explanation.className = 'error_explanation';\n        explanation.innerHTML = diagnostic.explanation;\n        div.appendChild(explanation);\n    }\n    errors_div.appendChild(div);\n}\nexports.report = report;\n\n\n//# sourceURL=webpack://thing/./build/ts/diagnostics.js?");

/***/ }),

/***/ "./build/ts/lexer.js":
/*!***************************!*\
  !*** ./build/ts/lexer.js ***!
  \***************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.lex = void 0;\nconst diagnostics = __importStar(__webpack_require__(/*! ./diagnostics */ \"./build/ts/diagnostics.js\"));\nclass BadCharacter {\n    constructor(ch) {\n        this.ch = ch;\n        this.message = `bad character: ${ch}`;\n        this.explanation = null;\n    }\n}\nclass UnterminatedString {\n    constructor() { this.message = \"unterminated string\"; this.explanation = null; }\n}\nclass Lexer {\n    constructor(source) {\n        this.source = source;\n        this.source = source;\n        this.ind = 0;\n    }\n    lex() {\n        let tokens = [];\n        while (!this.at_end()) {\n            let tok_start = this.ind;\n            let tok = this.lex_single_token(tok_start);\n            let tok_end = this.ind;\n            if (tok != null) {\n                tokens.push(Object.assign({ span: new diagnostics.Span(this.source, tok_start, tok_end) }, tok));\n            }\n        }\n        let eof = Object.assign(Object.assign({}, { type: \"eof\" }), { span: this.span(this.ind) });\n        return [tokens, eof];\n    }\n    lex_single_token(start_ind) {\n        let c = this.advance();\n        if (c == null) {\n            return null;\n        }\n        switch (c) {\n            case '(': return { type: \"'('\" };\n            case ')': return { type: \"')'\" };\n            case ',': return { type: \"','\" };\n            case '.': return { type: \"'.'\" };\n            case '+': return { type: \"'+'\" };\n            case '-': return { type: \"'-'\" };\n            case '*': return { type: \"'*'\" };\n            case '/':\n                if (this.match('/')) {\n                    while (!this.at_end() && this.peek() != '\\n') {\n                        this.advance();\n                    }\n                    ;\n                    return null;\n                }\n                else {\n                    return { type: \"'/'\" };\n                }\n            case '{': return { type: \"'{'\" };\n            case '}': return { type: \"'}'\" };\n            case ';': return { type: \"';'\" };\n            case ' ':\n            case '\\n':\n            case '\\r':\n            case '\\t':\n                return null;\n            case '!': return this.match('=') ? { type: \"'!='\" } : { type: \"'!'\" };\n            case '=': return this.match('=') ? { type: \"'=='\" } : { type: \"'='\" };\n            case '<': return this.match('=') ? { type: \"'<='\" } : { type: \"'<'\" };\n            case '>': return this.match('=') ? { type: \"'>='\" } : { type: \"'>'\" };\n            case '\"': return this.string(start_ind);\n            default:\n                if (this.is_digit(c)) {\n                    return this.number();\n                }\n                else if (this.is_alpha(c)) {\n                    return this.identifier();\n                }\n                else {\n                    diagnostics.report(Object.assign(Object.assign({}, new BadCharacter(c)), { span: this.span(start_ind) }));\n                    return null;\n                }\n        }\n    }\n    string(start_ind) {\n        let lit_start = this.ind;\n        while (!this.at_end() && this.peek() != '\"') {\n            this.advance();\n        }\n        if (this.at_end()) {\n            diagnostics.report(Object.assign(Object.assign({}, new UnterminatedString()), { span: this.span(start_ind) }));\n            return null;\n        }\n        let lit_end = this.ind;\n        this.advance();\n        let value = this.source.substring(lit_start, lit_end);\n        return { type: \"string literal\", str: value };\n    }\n    number() {\n        let start = this.ind - 1;\n        while (this.is_digit_(this.peek())) {\n            this.advance();\n        }\n        if (this.peek() == '.' && this.is_digit_(this.double_peek())) {\n            this.advance();\n            while (this.is_digit_(this.peek()))\n                this.advance();\n        }\n        return { type: \"number literal\", num: parseFloat(this.source.substring(start, this.ind)) };\n    }\n    identifier() {\n        let start = this.ind - 1;\n        while (this.is_alphanumeric_(this.peek())) {\n            this.advance();\n        }\n        let str = this.source.substring(start, this.ind);\n        switch (str) {\n            case \"and\": return { type: \"'and'\" };\n            case \"class\": return { type: \"'class'\" };\n            case \"else\": return { type: \"'else'\" };\n            case \"false\": return { type: \"bool literal\", bool: false };\n            case \"for\": return { type: \"'for'\" };\n            case \"fun\": return { type: \"'fun'\" };\n            case \"if\": return { type: \"'if'\" };\n            case \"nil\": return { type: \"'nil'\" };\n            case \"or\": return { type: \"'or'\" };\n            case \"print\": return { type: \"'print'\" };\n            case \"return\": return { type: \"'return'\" };\n            case \"super\": return { type: \"'super'\" };\n            case \"this\": return { type: \"'this'\" };\n            case \"true\": return { type: \"bool literal\", bool: true };\n            case \"var\": return { type: \"'var'\" };\n            case \"while\": return { type: \"'while'\" };\n            default: return { type: \"identifier\", name: str };\n        }\n    }\n    is_digit(x) {\n        return /\\d/.test(x);\n    }\n    is_digit_(x) {\n        if (x == null) {\n            return false;\n        }\n        return /\\d/.test(x);\n    }\n    is_alpha(x) {\n        return /[a-zA-Z]/.test(x);\n    }\n    is_alphanumeric(x) {\n        return this.is_digit(x) || this.is_alpha(x);\n    }\n    is_alphanumeric_(x) {\n        if (x == null) {\n            return false;\n        }\n        return this.is_digit(x) || this.is_alpha(x);\n    }\n    at_end() {\n        return this.ind >= this.source.length;\n    }\n    peek() {\n        if (this.at_end()) {\n            return null;\n        }\n        else {\n            return this.source[this.ind];\n        }\n    }\n    double_peek() {\n        if (this.ind + 1 >= this.source.length) {\n            return null;\n        }\n        else {\n            return this.source[this.ind + 1];\n        }\n    }\n    advance() {\n        if (this.at_end()) {\n            return null;\n        }\n        else {\n            return this.source[this.ind++];\n        }\n    }\n    match(x) {\n        if (this.peek() == x) {\n            this.advance();\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    span(start) {\n        return new diagnostics.Span(this.source, start, this.ind);\n    }\n}\nfunction lex(input) {\n    return new Lexer(input).lex();\n}\nexports.lex = lex;\n\n\n//# sourceURL=webpack://thing/./build/ts/lexer.js?");

/***/ }),

/***/ "./build/ts/main.js":
/*!**************************!*\
  !*** ./build/ts/main.js ***!
  \**************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst diagnostics = __importStar(__webpack_require__(/*! ./diagnostics */ \"./build/ts/diagnostics.js\"));\nconst lexer = __importStar(__webpack_require__(/*! ./lexer */ \"./build/ts/lexer.js\"));\nconst parser = __importStar(__webpack_require__(/*! ./parser */ \"./build/ts/parser.js\"));\nconst compiler = __importStar(__webpack_require__(/*! ./compiler */ \"./build/ts/compiler.js\"));\nconst vm = __importStar(__webpack_require__(/*! ./vm */ \"./build/ts/vm.js\"));\nlet editor = ace.edit(\"codeeditor\");\neditor.setOption(\"printMarginColumn\", false);\ndocument.getElementById('submitbutton').addEventListener('click', function () {\n    let input = editor.getValue();\n    diagnostics.clear();\n    {\n        let printoutput = document.getElementById('printoutput');\n        while (printoutput.lastChild) {\n            printoutput.removeChild(printoutput.lastChild);\n        }\n    }\n    let lexed = lexer.lex(input);\n    let parsed = parser.parse(lexed);\n    if (parsed) {\n        vm.interpret(compiler.compile(parsed));\n    }\n});\n\n\n//# sourceURL=webpack://thing/./build/ts/main.js?");

/***/ }),

/***/ "./build/ts/parser.js":
/*!****************************!*\
  !*** ./build/ts/parser.js ***!
  \****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parse = void 0;\nconst diagnostics = __importStar(__webpack_require__(/*! ./diagnostics */ \"./build/ts/diagnostics.js\"));\nconst ast = __importStar(__webpack_require__(/*! ./ast */ \"./build/ts/ast.js\"));\nconst peg = __importStar(__webpack_require__(/*! ./peg */ \"./build/ts/peg.js\"));\nfunction astify_binary_expr([comp, ops]) {\n    let cur;\n    while (cur = ops.shift()) {\n        let [op, right] = cur;\n        let op_ast;\n        switch (op.type) {\n            case \"'+'\":\n                op_ast = ast.BinaryOperator.Plus;\n                break;\n            case \"'-'\":\n                op_ast = ast.BinaryOperator.Minus;\n                break;\n            case \"'*'\":\n                op_ast = ast.BinaryOperator.Star;\n                break;\n            case \"'/'\":\n                op_ast = ast.BinaryOperator.Slash;\n                break;\n            case \"'<'\":\n                op_ast = ast.BinaryOperator.Less;\n                break;\n            case \"'>'\":\n                op_ast = ast.BinaryOperator.Greater;\n                break;\n            case \"'<='\":\n                op_ast = ast.BinaryOperator.LessEqual;\n                break;\n            case \"'=='\":\n                op_ast = ast.BinaryOperator.EqualEqual;\n                break;\n            case \"'>='\":\n                op_ast = ast.BinaryOperator.GreaterEqual;\n                break;\n            case \"'!='\":\n                op_ast = ast.BinaryOperator.BangEqual;\n                break;\n        }\n        comp = { type: 'BinaryExpr', span: diagnostics.join_spans(comp.span, right.span), left: comp, right, op: op_ast };\n    }\n    return comp;\n}\nfunction astify_logic_expr([comp, ops]) {\n    let cur;\n    while (cur = ops.shift()) {\n        let [op, right] = cur;\n        let op_ast;\n        switch (op.type) {\n            case \"'and'\":\n                op_ast = ast.LogicalOperator.And;\n                break;\n            case \"'or'\":\n                op_ast = ast.LogicalOperator.Or;\n                break;\n        }\n        comp = { type: 'LogicalExpr', span: diagnostics.join_spans(comp.span, right.span), left: comp, right, op: op_ast };\n    }\n    return comp;\n}\nlet block;\nlet expression;\nlet expression_indirect = () => expression;\nlet args = new peg.Indirect(expression_indirect).chain(new peg.ZeroMore(new peg.Token(\"','\").chain(new peg.Indirect(expression_indirect)))).apply(([first, more]) => [first].concat(more.map(x => x[1])));\nlet params = new peg.Token(\"identifier\").chain(new peg.ZeroMore(new peg.Token(\"','\").chain(new peg.Token(\"identifier\")))).apply(([first, more]) => [first].concat(more.map(x => x[1])));\nlet fn = new peg.Token(\"identifier\").chain(new peg.Token(\"'('\")).chain(new peg.Optional(params)).chain(new peg.Token(\"')'\")).chain(new peg.Indirect(() => block))\n    .apply(([[[[identifier, oparen], params], cparen], block]) => [identifier, params ? params : [], block]);\nlet primary = new peg.Token('bool literal').apply(tok => ({ type: 'BoolLiteral', span: tok.span, value: tok.bool })).choice(new peg.Token(\"'nil'\").apply(tok => ({ type: 'NilLiteral', span: tok.span }))).choice(new peg.Token('number literal').apply(tok => ({ type: 'NumberLiteral', span: tok.span, value: tok.num }))).choice(new peg.Token('string literal').apply(tok => ({ type: 'StringLiteral', span: tok.span, value: tok.str }))).choice(new peg.Token(\"identifier\").apply(ident => ({ type: 'VarExpr', span: ident.span, name: ident.name }))).choice(new peg.Token(\"'('\").chain(new peg.Indirect(expression_indirect)).chain(new peg.Token(\"')'\")).apply(([[oparen, expr], cparen]) => expr)); // TODO: track parenthesized expressions\nlet call = primary.chain(new peg.ZeroMore(new peg.Choice(new peg.Token(\"'('\").chain(new peg.Optional(args)).chain(new peg.Token(\"')'\")).apply(([[oparen, args], cparen]) => { let x = [args, cparen]; return x; }), new peg.Token(\"'.'\").chain(new peg.Token(\"identifier\")).apply(([dot, ident]) => ident)))).apply(([expr, ops]) => {\n    let cur_op;\n    while (cur_op = ops.shift()) {\n        if (!Array.isArray(cur_op)) {\n            let ident = cur_op;\n            // expr =\n            throw new Error(\"not implemented yet\"); // TODO\n        }\n        else {\n            let a;\n            if (cur_op[0]) {\n                a = cur_op[0];\n            }\n            else {\n                a = [];\n            }\n            expr = { type: 'CallExpr', span: diagnostics.join_spans(expr.span, cur_op[1].span), callee: expr, args: a };\n        }\n    }\n    return expr;\n});\nlet unary;\nunary =\n    (new peg.Token(\"'-'\").choice(new peg.Token(\"'!'\"))).chain(new peg.Indirect(() => unary)).apply(([op, expr]) => {\n        let op_ast;\n        switch (op.type) {\n            case \"'-'\":\n                op_ast = ast.UnaryOperator.Minus;\n                break;\n            case \"'!'\":\n                op_ast = ast.UnaryOperator.Bang;\n                break;\n            default: throw Error('unreachable');\n        }\n        return { type: 'UnaryExpr', span: diagnostics.join_spans(op.span, expr.span), operator: op_ast, operand: expr };\n    })\n        .choice(call);\nlet factor = new peg.Apply(astify_binary_expr, new peg.Chain(unary, new peg.ZeroMore(new peg.Chain(new peg.Choice(new peg.Token(\"'*'\"), new peg.Token(\"'/'\")), unary))));\nlet term = new peg.Apply(astify_binary_expr, new peg.Chain(factor, new peg.ZeroMore(new peg.Chain(new peg.Choice(new peg.Token(\"'+'\"), new peg.Token(\"'-'\")), factor))));\nlet comparison = new peg.Apply(astify_binary_expr, new peg.Chain(term, new peg.ZeroMore(new peg.Chain(new peg.Choice(new peg.Choice(new peg.Choice(new peg.Token(\"'<'\"), new peg.Token(\"'<='\")), new peg.Token(\"'>'\")), new peg.Token(\"'>='\")), term))));\nlet equality = new peg.Apply(astify_binary_expr, new peg.Chain(comparison, new peg.ZeroMore(new peg.Chain(new peg.Choice(new peg.Token(\"'=='\"), new peg.Token(\"'!='\")), comparison))));\nlet logic_and = equality.chain(new peg.ZeroMore(new peg.Token(\"'and'\").chain(equality))).apply(astify_logic_expr);\nlet logic_or = logic_and.chain(new peg.ZeroMore(new peg.Token(\"'or'\").chain(logic_and))).apply(astify_logic_expr);\nlet assignment;\nassignment =\n    new peg.Optional(call.chain(new peg.Token(\"'.'\"))).chain(new peg.Token(\"identifier\")).chain(new peg.Token(\"'='\")).chain(new peg.Indirect(() => assignment))\n        .apply(([[[m_call, ident], eq], assignment]) => ({ type: 'AssignExpr', span: diagnostics.join_spans(m_call ? m_call[0].span : ident.span, assignment.span), name: ident.name, value: assignment }))\n        .choice(logic_or);\nexpression = assignment;\nlet expr_stmt = new peg.Apply(([expr, semi]) => ({ type: 'ExprStmt', span: diagnostics.join_spans(expr.span, semi.span), expr }), new peg.Chain(new peg.Indirect(expression_indirect), new peg.Token(\"';'\")));\nlet print_stmt = new peg.Apply(([[print, expr], semi]) => ({ type: 'PrintStmt', span: diagnostics.join_spans(print.span, semi.span), expr }), new peg.Chain(new peg.Chain(new peg.Token(\"'print'\"), new peg.Indirect(expression_indirect)), new peg.Token(\"';'\")));\nlet var_decl;\nlet statement;\nlet statement_indirect = () => statement;\nlet declaration;\nlet declaration_indirect = () => declaration;\nlet for_stmt = new peg.Chain(new peg.Chain(new peg.Chain(new peg.Chain(new peg.Chain(new peg.Chain(new peg.Token(\"'for'\"), new peg.Token(\"'('\")), new peg.Choice(new peg.Choice(new peg.Indirect(() => var_decl), expr_stmt), new peg.Token(\"';'\").apply(() => null))), new peg.Chain(new peg.Optional(new peg.Indirect(expression_indirect)), new peg.Token(\"';'\"))), new peg.Optional(new peg.Indirect(expression_indirect))), new peg.Token(\"')'\")), new peg.Indirect(statement_indirect))\n    .apply(([[[[[[for_, oparen], initializer], cond], inc], cparen], body]) => {\n    return { type: 'ForStmt', span: diagnostics.join_spans(for_.span, body.span), initializer, compare: cond[0], increment: inc, body, for_sp: for_.span };\n});\nlet if_stmt = new peg.Apply(([[[[[if_, oparen], cond], cparen], body], m_else]) => ({ type: 'IfStmt', span: diagnostics.join_spans(if_.span, m_else ? m_else[1].span : body.span), condition: cond, then_branch: body, else_branch: m_else ? m_else[1] : null }), new peg.Chain(new peg.Chain(new peg.Chain(new peg.Chain(new peg.Chain(new peg.Token(\"'if'\"), new peg.Token(\"'('\")), new peg.Indirect(expression_indirect)), new peg.Token(\"')'\")), new peg.Indirect(statement_indirect)), new peg.Optional(new peg.Chain(new peg.Token(\"'else'\"), new peg.Indirect(statement_indirect)))));\nlet return_stmt = new peg.Apply(([[return_, m_expr], semi]) => ({ type: 'ReturnStmt', span: diagnostics.join_spans(return_.span, semi.span), value: m_expr }), new peg.Chain(new peg.Chain(new peg.Token(\"'return'\"), new peg.Optional(new peg.Indirect(expression_indirect))), new peg.Token(\"';'\")));\nlet while_stmt = new peg.Apply(([[[[while_, oparen], cond], cparen], body]) => ({ type: 'WhileStmt', span: diagnostics.join_spans(while_.span, body.span), condition: cond, body }), new peg.Chain(new peg.Chain(new peg.Chain(new peg.Chain(new peg.Token(\"'while'\"), new peg.Token(\"'('\")), new peg.Indirect(expression_indirect)), new peg.Token(\"')'\")), new peg.Indirect(statement_indirect)));\nblock =\n    new peg.Apply(([[obrace, stmts], cbrace]) => ({ type: 'BlockStmt', span: diagnostics.join_spans(obrace.span, cbrace.span), stmts, obrace_sp: obrace.span, cbrace_sp: cbrace.span }), new peg.Chain(new peg.Chain(new peg.Token(\"'{'\"), new peg.ZeroMore(new peg.Indirect(declaration_indirect))), new peg.Token(\"'}'\")));\nstatement =\n    expr_stmt\n        .choice(print_stmt)\n        .choice(for_stmt)\n        .choice(if_stmt)\n        .choice(return_stmt)\n        .choice(while_stmt)\n        .choice(block);\nvar_decl =\n    new peg.Apply(([[[var_, ident], m_initializer], semi]) => ({ type: 'VarStmt', span: diagnostics.join_spans(var_.span, semi.span), name: ident.name, initializer: m_initializer ? m_initializer[1] : null }), new peg.Chain(new peg.Chain(new peg.Chain(new peg.Token(\"'var'\"), new peg.Token(\"identifier\")), new peg.Optional(new peg.Chain(new peg.Token(\"'='\"), new peg.Indirect(expression_indirect)))), new peg.Token(\"';'\")));\nlet fun_decl = new peg.Chain(new peg.Token(\"'fun'\"), fn).apply(([fun, [identifier, params, block]]) => ({ type: 'FunctionStmt', span: diagnostics.join_spans(fun.span, block.span), name: identifier.name, params: params.map(x => x.name), body: block }));\ndeclaration = new peg.Choice(new peg.Choice(fun_decl, var_decl), statement);\nlet script = new peg.Apply(([stmts, eof]) => stmts, new peg.Chain(new peg.ZeroMore(declaration), new peg.Token(\"eof\")));\nfunction parse([tokens, eof]) {\n    let parser = new peg.Parser(tokens, eof);\n    let location = new peg.ParseLocation(parser, 0);\n    let res = script.parse(parser, location);\n    if (res) {\n        return res[1];\n    }\n    else {\n        parser.report_error();\n        return null;\n    }\n}\nexports.parse = parse;\n\n\n//# sourceURL=webpack://thing/./build/ts/parser.js?");

/***/ }),

/***/ "./build/ts/peg.js":
/*!*************************!*\
  !*** ./build/ts/peg.js ***!
  \*************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Indirect = exports.Apply = exports.OneMore = exports.ZeroMore = exports.Optional = exports.Choice = exports.Chain = exports.Token = exports.PEG = exports.ParseLocation = exports.Parser = void 0;\nconst diagnostics = __importStar(__webpack_require__(/*! ./diagnostics */ \"./build/ts/diagnostics.js\"));\nclass Parser {\n    constructor(tokens, eof) {\n        this.tokens = tokens;\n        this.eof = eof;\n        this.errors = new Map();\n    }\n    error(ind, expect) {\n        if (!this.errors.has(ind)) {\n            this.errors.set(ind, []);\n        }\n        this.errors.get(ind).push(expect);\n    }\n    report_error() {\n        let max_ind = Math.max(...this.errors.keys());\n        let got = this.get_tok(max_ind);\n        let es = this.errors.get(max_ind);\n        let explanation;\n        if (es.length == 1) {\n            explanation = `expected ${es[0]}, got ${got.type}`;\n        }\n        else {\n            explanation = `expected one of ${es}, got ${got.type}`;\n        }\n        diagnostics.report({\n            message: `parse error: ${explanation}`,\n            explanation: null,\n            span: got.span,\n        });\n    }\n    get_tok(ind) {\n        if (ind >= this.tokens.length) {\n            return this.eof;\n        }\n        else {\n            return this.tokens[ind];\n        }\n    }\n}\nexports.Parser = Parser;\nclass ParseLocation {\n    constructor(parser, ind) {\n        this.parser = parser;\n        this.ind = ind;\n    }\n    advance() {\n        return new ParseLocation(this.parser, this.ind + 1);\n    }\n    tok() { return this.parser.get_tok(this.ind); }\n}\nexports.ParseLocation = ParseLocation;\nclass PEG {\n    // convenience methods\n    chain(other) {\n        return new Chain(this, other);\n    }\n    choice(other) {\n        return new Choice(this, other);\n    }\n    apply(op) {\n        return new Apply(op, this);\n    }\n}\nexports.PEG = PEG;\nclass Token extends PEG {\n    constructor(type) {\n        super();\n        this.type = type;\n    }\n    parse(parser, location) {\n        let t = location.tok();\n        if (t.type == this.type) {\n            return [location.advance(), t];\n        }\n        else {\n            parser.error(location.ind, this.type);\n            return null;\n        }\n    }\n}\nexports.Token = Token;\nclass Chain extends PEG {\n    constructor(a, b) {\n        super();\n        this.a = a;\n        this.b = b;\n    }\n    parse(parser, location) {\n        let m_a_res = this.a.parse(parser, location);\n        if (m_a_res) {\n            let [location_, a_res] = m_a_res;\n            let m_b_res = this.b.parse(parser, location_);\n            if (m_b_res) {\n                let [location__, b_res] = m_b_res;\n                return [location__, [a_res, b_res]];\n            }\n        }\n        return null;\n    }\n}\nexports.Chain = Chain;\nclass Choice extends PEG {\n    constructor(a, b) {\n        super();\n        this.a = a;\n        this.b = b;\n    }\n    parse(parser, location) {\n        let m_a_res = this.a.parse(parser, location);\n        if (m_a_res) {\n            return m_a_res;\n        }\n        else {\n            let m_b_res = this.b.parse(parser, location);\n            if (m_b_res) {\n                return m_b_res;\n            }\n        }\n        return null;\n    }\n}\nexports.Choice = Choice;\nclass Optional extends PEG {\n    constructor(a) {\n        super();\n        this.a = a;\n    }\n    parse(parser, location) {\n        let m_a_res = this.a.parse(parser, location);\n        if (m_a_res) {\n            let [location_, a_res] = m_a_res;\n            return [location_, a_res];\n        }\n        else {\n            return [location, null];\n        }\n    }\n}\nexports.Optional = Optional;\nclass ZeroMore extends PEG {\n    constructor(a) {\n        super();\n        this.a = a;\n    }\n    parse(parser, location) {\n        let items = [];\n        while (true) {\n            let m_res = this.a.parse(parser, location);\n            if (m_res) {\n                let [location_, item] = m_res;\n                location = location_;\n                items.push(item);\n            }\n            else {\n                return [location, items];\n            }\n        }\n    }\n}\nexports.ZeroMore = ZeroMore;\nclass OneMore extends PEG {\n    constructor(a) {\n        super();\n        this.a = a;\n    }\n    parse(parser, location) {\n        return new Apply(([first, more]) => [first].concat(more), new Chain(this.a, new ZeroMore(this.a))).parse(parser, location);\n    }\n}\nexports.OneMore = OneMore;\nclass Apply extends PEG {\n    constructor(op, a) {\n        super();\n        this.op = op;\n        this.a = a;\n    }\n    parse(parser, location) {\n        let m_a_res = this.a.parse(parser, location);\n        if (m_a_res) {\n            let [location_, a_res] = m_a_res;\n            let b_res = this.op(a_res);\n            return [location_, b_res];\n        }\n        return null;\n    }\n}\nexports.Apply = Apply;\nclass Indirect extends PEG {\n    constructor(thing) {\n        super();\n        this.thing = thing;\n    }\n    parse(parser, location) {\n        return this.thing().parse(parser, location);\n    }\n}\nexports.Indirect = Indirect;\n\n\n//# sourceURL=webpack://thing/./build/ts/peg.js?");

/***/ }),

/***/ "./build/ts/runtime.js":
/*!*****************************!*\
  !*** ./build/ts/runtime.js ***!
  \*****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Bool = exports.Number = exports.String = exports.Function = exports.Nil = exports.Register = exports.Environment = void 0;\nconst vm = __importStar(__webpack_require__(/*! ./vm */ \"./build/ts/vm.js\"));\nclass Environment {\n    constructor(parent) {\n        this.parent = parent;\n        this.variables = new Map();\n    }\n    get_variable(name) {\n        if (this.variables.has(name))\n            return this.variables.get(name);\n        else if (this.parent != null)\n            return this.parent.get_variable(name);\n        else\n            throw new Error(`get variable that does not exist: '${name}'`); // TODO: new runtime error class to catch\n    }\n    set_variable(name, value) {\n        if (this.variables.has(name))\n            this.variables.set(name, value);\n        else if (this.parent != null)\n            this.parent.set_variable(name, value);\n        else\n            throw new Error(`set variable that does not exist: '${name}'`); // TODO: new runtime error class to catch\n    }\n    put_variable(name, value) {\n        this.variables.set(name, value);\n    }\n}\nexports.Environment = Environment;\nclass Register {\n    constructor(index) {\n        this.index = index;\n    }\n    pretty_print() { return `%${this.index}`; }\n    resolve(registers) {\n        return registers[this.index];\n    }\n}\nexports.Register = Register;\nclass Nil {\n    constructor() { }\n    pretty_print() { return this.stringify(); }\n    resolve() { return this; }\n    is_truthy() { return false; }\n    type() { return 'nil'; }\n    stringify() { return 'nil'; }\n}\nexports.Nil = Nil;\nclass Function {\n    constructor(name, params, instructions) {\n        this.name = name;\n        this.params = params;\n        this.instructions = instructions;\n        this.arity = this.params.length;\n    }\n    pretty_print() { return `<function>`; }\n    resolve() { return this; }\n    is_truthy() { return true; }\n    type() { return 'function'; }\n    stringify() { return `<function '${this.name}'>`; }\n    call(globals, args) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let env = new Environment(globals);\n            for (let i = 0; i < this.params.length; ++i) { // should be same size\n                env.put_variable(this.params[i], args[i]);\n            }\n            return yield vm.interpret_(globals, env, this.instructions);\n        });\n    }\n}\nexports.Function = Function;\nclass String {\n    constructor(x) {\n        this.x = x;\n    }\n    pretty_print() { return `\"${this.x}\"`; }\n    resolve() { return this; }\n    is_truthy() { return true; }\n    type() { return 'string'; }\n    stringify() { return this.x; }\n    ;\n}\nexports.String = String;\nclass Number {\n    constructor(x) {\n        this.x = x;\n    }\n    pretty_print() { return this.x.toString(); }\n    resolve() { return this; }\n    is_truthy() { return true; }\n    type() { return 'number'; }\n    stringify() { return this.x.toString(); }\n}\nexports.Number = Number;\nclass Bool {\n    constructor(x) {\n        this.x = x;\n    }\n    pretty_print() { return this.x.toString(); }\n    resolve() { return this; }\n    is_truthy() { return this.x; }\n    type() { return 'bool'; }\n    stringify() { return this.x.toString(); }\n}\nexports.Bool = Bool;\n\n\n//# sourceURL=webpack://thing/./build/ts/runtime.js?");

/***/ }),

/***/ "./build/ts/visualization.js":
/*!***********************************!*\
  !*** ./build/ts/visualization.js ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CallStackFrame = void 0;\nconst bytecode = __importStar(__webpack_require__(/*! ./bytecode */ \"./build/ts/bytecode.js\"));\nclass CallStackFrame {\n    constructor(instrs) {\n        [this.pp, this.mapping] = bytecode.pretty_print(instrs);\n        this.elem = document.createElement(\"div\");\n        this.elem.className = \"callstackframe\";\n        let pre = document.createElement(\"pre\");\n        this.code = document.createElement(\"code\");\n        pre.appendChild(this.code);\n        this.elem.appendChild(pre);\n        let callstack = document.getElementById(\"callstack\");\n        callstack.insertBefore(this.elem, callstack.firstChild);\n    }\n    focus_instr(instr) {\n        let [start, end] = this.mapping.get(instr);\n        let before_text = document.createTextNode(this.pp.substring(0, start));\n        let instr_text = document.createTextNode(this.pp.substring(start, end));\n        let after_text = document.createTextNode(this.pp.substring(end));\n        let instr_span = document.createElement('span');\n        instr_span.className = \"cur_instruction\";\n        instr_span.appendChild(instr_text);\n        this.code.innerHTML = \"\";\n        this.code.appendChild(before_text);\n        this.code.appendChild(instr_span);\n        this.code.appendChild(after_text);\n    }\n    done() {\n        document.getElementById(\"callstack\").removeChild(this.elem);\n    }\n}\nexports.CallStackFrame = CallStackFrame;\n\n\n//# sourceURL=webpack://thing/./build/ts/visualization.js?");

/***/ }),

/***/ "./build/ts/vm.js":
/*!************************!*\
  !*** ./build/ts/vm.js ***!
  \************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.interpret_ = exports.interpret = void 0;\nconst runtime = __importStar(__webpack_require__(/*! ./runtime */ \"./build/ts/runtime.js\"));\nconst ast = __importStar(__webpack_require__(/*! ./ast */ \"./build/ts/ast.js\"));\nconst visualization = __importStar(__webpack_require__(/*! ./visualization */ \"./build/ts/visualization.js\"));\nfunction* instruction_list(registers, instructions) {\n    for (let instr of instructions) {\n        yield* instruction_list_1(registers, instr);\n    }\n}\nfunction* instruction_list_1(registers, instr) {\n    switch (instr.type) {\n        case 'If': {\n            if (instr.cond.resolve(registers).is_truthy()) {\n                yield* instruction_list(registers, instr.true_branch);\n            }\n            else {\n                if (instr.false_branch) {\n                    yield* instruction_list(registers, instr.false_branch);\n                }\n            }\n            break;\n        }\n        case 'While': {\n            while (true) {\n                yield* instruction_list(registers, instr.check_code);\n                if (!instr.check.resolve(registers).is_truthy())\n                    break;\n                yield* instruction_list(registers, instr.body_code);\n            }\n            break;\n        }\n        case 'StmtMarker': break;\n        default: {\n            yield instr;\n            break;\n        }\n    }\n}\nfunction interpret(instructions) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let globals = new runtime.Environment(null);\n        interpret_(globals, globals, instructions);\n    });\n}\nexports.interpret = interpret;\nfunction interpret_(globals, env, instructions) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let tracker = new visualization.CallStackFrame(instructions);\n        let registers = [];\n        for (let instr of instruction_list(registers, instructions)) {\n            tracker.focus_instr(instr);\n            yield new Promise((resolve) => document.getElementById(\"stepbutton\").addEventListener(\"click\", resolve));\n            switch (instr.type) {\n                case 'StmtMarker': break;\n                case 'UnaryOp': {\n                    let value = instr.v.resolve(registers);\n                    let result;\n                    switch (instr.op) {\n                        case ast.UnaryOperator.Minus:\n                            if (value instanceof runtime.Number) {\n                                result = new runtime.Number(-value.x);\n                            }\n                            else {\n                                throw new Error(`cannot negate non-number ${value.type()}`); // TODO\n                            }\n                            break;\n                        case ast.UnaryOperator.Bang:\n                            result = new runtime.Bool(!value.is_truthy());\n                            break;\n                    }\n                    registers[instr.dest.index] = result;\n                    break;\n                }\n                case 'BinaryOp': {\n                    let l = instr.l.resolve(registers);\n                    let r = instr.r.resolve(registers);\n                    let result;\n                    let cannot_compare = new Error(`cannot compare ${l.type()} and ${r.type()}; can only compare number and number`);\n                    switch (instr.op) {\n                        case ast.BinaryOperator.Plus: {\n                            if (l instanceof runtime.Number && r instanceof runtime.Number) {\n                                result = new runtime.Number(l.x + r.x);\n                            }\n                            else if (l instanceof runtime.String && r instanceof runtime.String) {\n                                result = new runtime.String(l.x + r.x);\n                            }\n                            else {\n                                throw new Error(`cannot add ${l.type()} and ${r.type()}; can only add number and number or string and string`);\n                            }\n                            break;\n                        }\n                        case ast.BinaryOperator.Minus: {\n                            if (l instanceof runtime.Number && r instanceof runtime.Number) {\n                                result = new runtime.Number(l.x - r.x);\n                            }\n                            else {\n                                throw new Error(`cannot subtract ${l.type()} and ${r.type()}; can only subtract number and number`);\n                            }\n                            break;\n                        }\n                        case ast.BinaryOperator.Star: {\n                            if (l instanceof runtime.Number && r instanceof runtime.Number) {\n                                result = new runtime.Number(l.x * r.x);\n                            }\n                            else {\n                                throw new Error(`cannot multiply ${l.type()} and ${r.type()}; can only multiply number and number`);\n                            }\n                            break;\n                        }\n                        case ast.BinaryOperator.Slash: {\n                            if (l instanceof runtime.Number && r instanceof runtime.Number) {\n                                result = new runtime.Number(l.x / r.x);\n                            }\n                            else {\n                                throw new Error(`cannot divide ${l.type()} and ${r.type()}; can only divide number and number`);\n                            }\n                            break;\n                        }\n                        case ast.BinaryOperator.Less: {\n                            if (l instanceof runtime.Number && r instanceof runtime.Number) {\n                                result = new runtime.Bool(l.x < r.x);\n                            }\n                            else {\n                                throw cannot_compare;\n                            }\n                            break;\n                        }\n                        case ast.BinaryOperator.Greater: {\n                            if (l instanceof runtime.Number && r instanceof runtime.Number) {\n                                result = new runtime.Bool(l.x > r.x);\n                            }\n                            else {\n                                throw cannot_compare;\n                            }\n                            break;\n                        }\n                        case ast.BinaryOperator.LessEqual: {\n                            if (l instanceof runtime.Number && r instanceof runtime.Number) {\n                                result = new runtime.Bool(l.x <= r.x);\n                            }\n                            else {\n                                throw cannot_compare;\n                            }\n                            break;\n                        }\n                        case ast.BinaryOperator.GreaterEqual: {\n                            if (l instanceof runtime.Number && r instanceof runtime.Number) {\n                                result = new runtime.Bool(l.x >= r.x);\n                            }\n                            else {\n                                throw cannot_compare;\n                            }\n                            break;\n                        }\n                        case ast.BinaryOperator.EqualEqual: {\n                            if (l instanceof runtime.Nil && r instanceof runtime.Nil) {\n                                result = new runtime.Bool(true);\n                            }\n                            else if (l instanceof runtime.Number && r instanceof runtime.Number) {\n                                result = new runtime.Bool(l.x == r.x);\n                            }\n                            else if (l instanceof runtime.String && r instanceof runtime.String) {\n                                result = new runtime.Bool(l.x == r.x);\n                            }\n                            else if (l instanceof runtime.Bool && r instanceof runtime.Bool) {\n                                result = new runtime.Bool(l.x == r.x);\n                            }\n                            else if (l instanceof runtime.Function && r instanceof runtime.Function) {\n                                result = new runtime.Bool(false);\n                            }\n                            break;\n                        }\n                        case ast.BinaryOperator.BangEqual: {\n                            result = new runtime.Bool(l != r);\n                            break;\n                        }\n                    }\n                    registers[instr.dest.index] = result; // TODO: remove !\n                    break;\n                }\n                case 'Call': {\n                    let callee = instr.callee.resolve(registers);\n                    let args = instr.args.map(x => x.resolve(registers));\n                    if (!('call' in callee && 'arity' in callee))\n                        throw new Error(\"can only call functions and classes\");\n                    let callee_ = callee;\n                    if (args.length != callee_.arity)\n                        throw new Error(`wrong number of arguments: expected ${callee_.arity}, got ${args.length}`);\n                    else\n                        registers[instr.dest.index] = yield callee_.call(globals, args);\n                    break;\n                }\n                case 'Assign': {\n                    env.set_variable(instr.name, instr.value.resolve(registers));\n                    break;\n                }\n                case 'MakeVar': {\n                    env.put_variable(instr.name, instr.value.resolve(registers));\n                    break;\n                }\n                case 'ReadVar': {\n                    registers[instr.dest.index] = env.get_variable(instr.name);\n                    break;\n                }\n                case 'StartScope': {\n                    env = new runtime.Environment(env);\n                    break;\n                }\n                case 'EndScope': {\n                    env = env.parent;\n                    break;\n                }\n                case 'Return': {\n                    tracker.done();\n                    return instr.value.resolve(registers);\n                }\n                case 'Print': {\n                    let tn = document.createTextNode(instr.value.resolve(registers).stringify());\n                    let p = document.createElement('p');\n                    p.appendChild(tn);\n                    document.getElementById('printoutput').appendChild(p);\n                    break;\n                }\n                case 'If': break; // handled by instruction_list\n                case 'While': break; // handled by instruction_list\n            }\n        }\n        tracker.done();\n        return new runtime.Nil();\n    });\n}\nexports.interpret_ = interpret_;\n\n\n//# sourceURL=webpack://thing/./build/ts/vm.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./build/ts/main.js");
/******/ 	
/******/ })()
;
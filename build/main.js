/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./build/ts/ast.js":
/*!*************************!*\
  !*** ./build/ts/ast.js ***!
  \*************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LogicalOperator = exports.UnaryOperator = exports.BinaryOperator = void 0;\n// | ClassStmt\nvar BinaryOperator;\n(function (BinaryOperator) {\n    BinaryOperator[BinaryOperator[\"Plus\"] = 0] = \"Plus\";\n    BinaryOperator[BinaryOperator[\"Minus\"] = 1] = \"Minus\";\n    BinaryOperator[BinaryOperator[\"Star\"] = 2] = \"Star\";\n    BinaryOperator[BinaryOperator[\"Slash\"] = 3] = \"Slash\";\n    BinaryOperator[BinaryOperator[\"Less\"] = 4] = \"Less\";\n    BinaryOperator[BinaryOperator[\"Greater\"] = 5] = \"Greater\";\n    BinaryOperator[BinaryOperator[\"LessEqual\"] = 6] = \"LessEqual\";\n    BinaryOperator[BinaryOperator[\"GreaterEqual\"] = 7] = \"GreaterEqual\";\n    BinaryOperator[BinaryOperator[\"EqualEqual\"] = 8] = \"EqualEqual\";\n    BinaryOperator[BinaryOperator[\"BangEqual\"] = 9] = \"BangEqual\";\n})(BinaryOperator = exports.BinaryOperator || (exports.BinaryOperator = {}));\nvar UnaryOperator;\n(function (UnaryOperator) {\n    UnaryOperator[UnaryOperator[\"Minus\"] = 0] = \"Minus\";\n    UnaryOperator[UnaryOperator[\"Bang\"] = 1] = \"Bang\";\n})(UnaryOperator = exports.UnaryOperator || (exports.UnaryOperator = {}));\nvar LogicalOperator;\n(function (LogicalOperator) {\n    LogicalOperator[LogicalOperator[\"And\"] = 0] = \"And\";\n    LogicalOperator[LogicalOperator[\"Or\"] = 1] = \"Or\";\n})(LogicalOperator = exports.LogicalOperator || (exports.LogicalOperator = {}));\n\n\n//# sourceURL=webpack://thing/./build/ts/ast.js?");

/***/ }),

/***/ "./build/ts/bytecode.js":
/*!******************************!*\
  !*** ./build/ts/bytecode.js ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PrettyPrintContext = exports.StmtMarker = exports.UnaryOp = exports.BinaryOp = exports.Call = exports.Assign = exports.ReadVar = exports.EndScope = exports.StartScope = exports.Return = exports.If = exports.While = exports.MakeVar = exports.Print = void 0;\nconst diagnostics = __importStar(__webpack_require__(/*! ./diagnostics */ \"./build/ts/diagnostics.js\"));\nconst ast = __importStar(__webpack_require__(/*! ./ast */ \"./build/ts/ast.js\"));\nclass Print {\n    constructor(span, expr) {\n        this.span = span;\n        this.expr = expr;\n    }\n    pretty_print(ppc) {\n        ppc.append(`print ${this.expr.pretty_print()};`, this.span);\n    }\n    accept(visitor) {\n        return visitor.visitPrint(this);\n    }\n}\nexports.Print = Print;\nclass MakeVar {\n    constructor(span, name, value) {\n        this.span = span;\n        this.name = name;\n        this.value = value;\n    }\n    pretty_print(ppc) {\n        ppc.append(`make_var ${this.name} = ${this.value.pretty_print()};`, this.span);\n    }\n    accept(visitor) {\n        return visitor.visitMakeVar(this);\n    }\n}\nexports.MakeVar = MakeVar;\nclass While {\n    constructor(span, check_code, check, body_code) {\n        this.span = span;\n        this.check_code = check_code;\n        this.check = check;\n        this.body_code = body_code;\n    }\n    pretty_print(ppc) {\n        ppc.append('while {', this.span);\n        ppc.indent();\n        ppc.pretty_print_instrs(this.check_code);\n        ppc.append_no_span(`check ${this.check.pretty_print()}`);\n        ppc.dedent();\n        ppc.append_no_span('}');\n        ppc.append_no_span('{');\n        ppc.indent();\n        ppc.pretty_print_instrs(this.body_code);\n        ppc.dedent();\n        ppc.append_no_span('}');\n    }\n    accept(visitor) {\n        return visitor.visitWhile(this);\n    }\n}\nexports.While = While;\nclass If {\n    constructor(span, cond, true_branch, false_branch) {\n        this.span = span;\n        this.cond = cond;\n        this.true_branch = true_branch;\n        this.false_branch = false_branch;\n    }\n    pretty_print(ppc) {\n        ppc.append('if ${this.cond.pretty_print()} {', this.span);\n        ppc.indent();\n        ppc.pretty_print_instrs(this.true_branch);\n        ppc.dedent();\n        if (this.false_branch) {\n            ppc.append_no_span('} else {');\n            ppc.indent();\n            ppc.pretty_print_instrs(this.false_branch);\n            ppc.dedent();\n            ppc.append_no_span('}');\n        }\n        else {\n            ppc.append_no_span('}');\n        }\n    }\n    accept(visitor) {\n        return visitor.visitIf(this);\n    }\n}\nexports.If = If;\nclass Return {\n    constructor(span, v) {\n        this.span = span;\n        this.v = v;\n    }\n    pretty_print(ppc) {\n        ppc.append(`return ${this.v.pretty_print()};`, this.span);\n    }\n    accept(visitor) {\n        return visitor.visitReturn(this);\n    }\n}\nexports.Return = Return;\nclass StartScope {\n    constructor(span) {\n        this.span = span;\n    }\n    pretty_print(ppc) {\n        ppc.append(`start_scope;`, this.span);\n    }\n    accept(visitor) {\n        return visitor.visitStartScope(this);\n    }\n}\nexports.StartScope = StartScope;\nclass EndScope {\n    constructor(span) {\n        this.span = span;\n    }\n    pretty_print(ppc) {\n        ppc.append(`end_scope;`, this.span);\n    }\n    accept(visitor) {\n        return visitor.visitEndScope(this);\n    }\n}\nexports.EndScope = EndScope;\nclass ReadVar {\n    constructor(span, v, dest) {\n        this.span = span;\n        this.v = v;\n        this.dest = dest;\n    }\n    pretty_print(ppc) {\n        ppc.append(`read_var ${this.v} -> ${this.dest.pretty_print()};`, this.span);\n    }\n    accept(visitor) {\n        return visitor.visitReadVar(this);\n    }\n}\nexports.ReadVar = ReadVar;\nclass Assign {\n    constructor(span, variable, value) {\n        this.span = span;\n        this.variable = variable;\n        this.value = value;\n    }\n    pretty_print(ppc) {\n        ppc.append(`assign ${this.variable} = ${this.value.pretty_print()};`, this.span);\n    }\n    accept(visitor) {\n        return visitor.visitAssign(this);\n    }\n}\nexports.Assign = Assign;\nclass Call {\n    constructor(span, callee, args, dest) {\n        this.span = span;\n        this.callee = callee;\n        this.args = args;\n        this.dest = dest;\n    }\n    pretty_print(ppc) {\n        ppc.append(`call ${this.callee.pretty_print()}(${this.args.map(a => a.pretty_print()).join()}) -> ${this.dest.pretty_print()};`, this.span);\n    }\n    accept(visitor) {\n        return visitor.visitCall(this);\n    }\n}\nexports.Call = Call;\nclass BinaryOp {\n    constructor(span, l, r, op, dest) {\n        this.span = span;\n        this.l = l;\n        this.r = r;\n        this.op = op;\n        this.dest = dest;\n    }\n    pretty_print(ppc) {\n        let op_name;\n        switch (this.op) {\n            case ast.BinaryOperator.Plus:\n                op_name = 'add';\n                break;\n            case ast.BinaryOperator.Minus:\n                op_name = 'sub';\n                break;\n            case ast.BinaryOperator.Star:\n                op_name = 'mul';\n                break;\n            case ast.BinaryOperator.Slash:\n                op_name = 'div';\n                break;\n            case ast.BinaryOperator.Less:\n                op_name = 'cmp<';\n                break;\n            case ast.BinaryOperator.Greater:\n                op_name = 'cmp>';\n                break;\n            case ast.BinaryOperator.LessEqual:\n                op_name = 'cmp<=';\n                break;\n            case ast.BinaryOperator.EqualEqual:\n                op_name = 'cmp==';\n                break;\n            case ast.BinaryOperator.GreaterEqual:\n                op_name = 'cmp>=';\n                break;\n            case ast.BinaryOperator.BangEqual:\n                op_name = 'cmp!=';\n                break;\n        }\n        ppc.append(`${op_name} ${this.l.pretty_print()} ${this.r.pretty_print()} -> ${this.dest.pretty_print()};`, this.span);\n    }\n    accept(visitor) {\n        return visitor.visitBinaryOp(this);\n    }\n}\nexports.BinaryOp = BinaryOp;\nclass UnaryOp {\n    constructor(span, v, op, dest) {\n        this.span = span;\n        this.v = v;\n        this.op = op;\n        this.dest = dest;\n    }\n    pretty_print(ppc) {\n        let op_name;\n        switch (this.op) {\n            case ast.UnaryOperator.Minus:\n                op_name = 'neg';\n                break;\n            case ast.UnaryOperator.Bang:\n                op_name = 'logic_neg';\n                break;\n        }\n        ppc.append(`${op_name} ${this.v.pretty_print()} -> ${this.dest.pretty_print()};`, this.span);\n    }\n    accept(visitor) {\n        return visitor.visitUnaryOp(this);\n    }\n}\nexports.UnaryOp = UnaryOp;\nclass StmtMarker {\n    constructor(span) {\n        this.span = span;\n    }\n    pretty_print(ppc) {\n        ppc.append_marker(`// line ${this.span.start_line}: ${diagnostics.get_line(this.span.source, this.span.start_line)}`);\n    }\n    accept(visitor) {\n        return visitor.visitStmtMarker(this);\n    }\n}\nexports.StmtMarker = StmtMarker;\nclass PrettyPrintContext {\n    constructor() {\n        this.indentation = 0;\n        this.result = '';\n    }\n    indent() {\n        ++this.indentation;\n    }\n    dedent() {\n        --this.indentation;\n    }\n    blank_line() {\n        this.result += '\\n';\n    }\n    append(s, sp) {\n        let sp_contents = sp.contents;\n        let sp_annotation = sp_contents.split('\\n').length > 1 ? `${sp_contents.split('\\n')[0]}...` : sp_contents;\n        this.append_no_span(`${s}${' '.repeat(40 - s.length)}// ${sp_annotation}`);\n    }\n    append_no_span(s) {\n        this.result += `${' '.repeat(this.indentation * 4)}${s}\\n`;\n    }\n    append_marker(s) {\n        this.blank_line();\n        this.append_no_span(s);\n    }\n    pretty_print_instrs(instrs) {\n        for (let instr of instrs) {\n            instr.pretty_print(this);\n        }\n    }\n}\nexports.PrettyPrintContext = PrettyPrintContext;\n\n\n//# sourceURL=webpack://thing/./build/ts/bytecode.js?");

/***/ }),

/***/ "./build/ts/compiler.js":
/*!******************************!*\
  !*** ./build/ts/compiler.js ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.compile = void 0;\nconst bytecode = __importStar(__webpack_require__(/*! ./bytecode */ \"./build/ts/bytecode.js\"));\nconst runtime = __importStar(__webpack_require__(/*! ./runtime */ \"./build/ts/runtime.js\"));\nclass RegisterContext {\n    constructor() {\n        this.register_i = 0;\n    }\n    new_register() {\n        return new runtime.Register(this.register_i++);\n    }\n}\nfunction make_stmt_marker(stmt) {\n    return new bytecode.StmtMarker(stmt.span);\n}\nfunction compile(stmts) {\n    let register_context = new RegisterContext();\n    let instructions = [];\n    for (let stmt of stmts) {\n        compile_stmt(stmt, instructions, register_context);\n    }\n    return instructions;\n}\nexports.compile = compile;\nfunction compile_stmt(stmt, instructions, register_context) {\n    instructions.push(make_stmt_marker(stmt));\n    switch (stmt.type) {\n        case 'ExprStmt': {\n            compile_expr(stmt.expr, instructions, register_context);\n            break;\n        }\n        case 'PrintStmt': {\n            let e = compile_expr(stmt.expr, instructions, register_context);\n            instructions.push(new bytecode.Print(stmt.span, e));\n            break;\n        }\n        case 'VarStmt': {\n            let e;\n            if (stmt.initializer) {\n                e = compile_expr(stmt.initializer, instructions, register_context);\n            }\n            else {\n                e = new runtime.Nil();\n            }\n            instructions.push(new bytecode.MakeVar(stmt.span, stmt.name, e));\n            break;\n        }\n        case 'BlockStmt': {\n            instructions.push(new bytecode.StartScope(stmt.obrace_sp));\n            for (let sub_stmt of stmt.stmts) {\n                compile_stmt(sub_stmt, instructions, register_context);\n            }\n            instructions.push(new bytecode.EndScope(stmt.cbrace_sp));\n            break;\n        }\n        case 'FunctionStmt': {\n            let register_context = new RegisterContext();\n            let instrs = [];\n            compile_stmt(stmt.body, instrs, register_context);\n            let fn = new runtime.Function(stmt.name, stmt.params, instructions);\n            instructions.push(new bytecode.MakeVar(stmt.span, stmt.name, fn));\n            break;\n        }\n        case 'ForStmt': {\n            instructions.push(new bytecode.StartScope(stmt.for_sp));\n            if (stmt.initializer) {\n                compile_stmt(stmt.initializer, instructions, register_context);\n            }\n            let check_code = [];\n            let check;\n            if (stmt.compare) {\n                check = compile_expr(stmt.compare, check_code, register_context);\n            }\n            else {\n                check = new runtime.Bool(true);\n            }\n            let body_code = [];\n            compile_stmt(stmt.body, body_code, register_context);\n            if (stmt.increment) {\n                compile_expr(stmt.increment, body_code, register_context);\n            }\n            instructions.push(new bytecode.While(stmt.span, check_code, check, body_code));\n            instructions.push(new bytecode.EndScope(stmt.for_sp)); // TODO: better span?\n            break;\n        }\n        case 'IfStmt': {\n            let cond = compile_expr(stmt.condition, instructions, register_context);\n            let true_code = [];\n            compile_stmt(stmt.then_branch, true_code, register_context);\n            let false_code;\n            if (stmt.else_branch) {\n                false_code = [];\n                compile_stmt(stmt.else_branch, false_code, register_context);\n            }\n            else {\n                false_code = null;\n            }\n            instructions.push(new bytecode.If(stmt.span, cond, true_code, false_code));\n            break;\n        }\n        case 'ReturnStmt': {\n            let e;\n            if (stmt.value) {\n                e = compile_expr(stmt.value, instructions, register_context);\n            }\n            else {\n                e = new runtime.Nil();\n            }\n            instructions.push(new bytecode.Return(stmt.span, e));\n            break;\n        }\n        case 'WhileStmt': {\n            let check_code = [];\n            let check = compile_expr(stmt.condition, check_code, register_context);\n            let body_code = [];\n            compile_stmt(stmt.body, body_code, register_context);\n            instructions.push(new bytecode.While(stmt.span, check_code, check, body_code));\n            break;\n        }\n    }\n}\nfunction compile_expr(expr, instructions, register_context) {\n    switch (expr.type) {\n        case 'BinaryExpr': {\n            let l = compile_expr(expr.left, instructions, register_context);\n            let r = compile_expr(expr.right, instructions, register_context);\n            let reg = register_context.new_register();\n            instructions.push(new bytecode.BinaryOp(expr.span, l, r, expr.op, reg));\n            return reg;\n        }\n        case 'UnaryExpr': {\n            let v = compile_expr(expr.operand, instructions, register_context);\n            let reg = register_context.new_register();\n            instructions.push(new bytecode.UnaryOp(expr.span, v, expr.operator, reg));\n            return reg;\n        }\n        case 'VarExpr': {\n            let reg = register_context.new_register();\n            instructions.push(new bytecode.ReadVar(expr.span, expr.name, reg));\n            return reg;\n        }\n        case 'StringLiteral': {\n            return new runtime.String(expr.value);\n        }\n        case 'NumberLiteral': {\n            return new runtime.Number(expr.value);\n        }\n        case 'BoolLiteral': {\n            return new runtime.Bool(expr.value);\n        }\n        case 'NilLiteral': {\n            return new runtime.Nil();\n        }\n        case 'AssignExpr': {\n            let v = compile_expr(expr.value, instructions, register_context);\n            instructions.push(new bytecode.Assign(expr.span, expr.name, v));\n            return v;\n        }\n        case 'CallExpr': {\n            let callee = compile_expr(expr.callee, instructions, register_context);\n            let args = [];\n            for (let a_ast of expr.args) {\n                args.push(compile_expr(a_ast, instructions, register_context));\n            }\n            let reg = register_context.new_register();\n            instructions.push(new bytecode.Call(expr.span, callee, args, reg));\n            return reg;\n        }\n        case 'LogicalExpr': {\n            throw new Error(\"not implemented yet\"); // TODO\n        }\n    }\n}\n\n\n//# sourceURL=webpack://thing/./build/ts/compiler.js?");

/***/ }),

/***/ "./build/ts/diagnostics.js":
/*!*********************************!*\
  !*** ./build/ts/diagnostics.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.report = exports.join_spans = exports.clear = exports.get_line = exports.Span = void 0;\nconst errors_div = document.getElementById('errors');\nclass Span {\n    constructor(source, start, end) {\n        this.source = source;\n        this.start = start;\n        this.end = end;\n        [this.start_line, this.start_column] = get_linecol(source, start);\n        [this.end_line, this.end_column] = get_linecol(source, end);\n        this.contents = source.substring(start, end);\n    }\n}\nexports.Span = Span;\nfunction get_linecol(source, ind) {\n    let line = (source.substring(0, ind).match(/^/mg) || []).length;\n    let lines = source.substring(0, ind).match(/^.+/mg);\n    if (lines) {\n        return [line, lines[lines.length - 1].length + 1];\n    }\n    else {\n        return [line, 0];\n    }\n}\nfunction get_line(source, line) {\n    return source.split('\\n')[line - 1];\n}\nexports.get_line = get_line;\nfunction clear() {\n    while (errors_div.lastChild) {\n        errors_div.removeChild(errors_div.lastChild);\n    }\n}\nexports.clear = clear;\nfunction join_spans(sp1, sp2) {\n    return new Span(sp1.source, Math.min(sp1.start, sp2.start), Math.max(sp1.end, sp2.end));\n}\nexports.join_spans = join_spans;\nfunction report(diagnostic) {\n    let div = document.createElement('div');\n    div.className = 'error';\n    {\n        let heading = document.createElement('p');\n        heading.className = 'error_heading';\n        heading.innerHTML = `error at ${diagnostic.span.start_line}:${diagnostic.span.start_column}: ${diagnostic.message}`;\n        div.appendChild(heading);\n    }\n    {\n        function make_line_view(source, nr, highlight_start_col, highlight_end_col) {\n            let line_view = document.createElement('div');\n            line_view.className = 'error_line_view';\n            let line_number = document.createElement('p');\n            line_number.innerHTML = nr.toString();\n            line_number.className = 'error_linenumber';\n            let pre = document.createElement('pre');\n            let code = document.createElement('code');\n            pre.className = 'error_pre';\n            code.className = 'error_code';\n            if (highlight_start_col == null || highlight_end_col == null) {\n                code.innerHTML = source[nr - 1];\n            }\n            else {\n                let line_contents = source[nr - 1];\n                let start = highlight_start_col - 1;\n                let end = highlight_end_col == -1 ? line_contents.length : highlight_end_col - 1;\n                code.innerHTML = `${line_contents.substring(0, start)}<strong>${line_contents.substring(start, end)}</strong>${line_contents.substring(end)}`;\n            }\n            line_view.appendChild(line_number);\n            pre.appendChild(code);\n            line_view.appendChild(pre);\n            return line_view;\n        }\n        let view = document.createElement('div');\n        view.className = 'error_view';\n        let source_lines = diagnostic.span.source.split('\\n');\n        for (let i = diagnostic.span.start_line; i <= diagnostic.span.end_line; ++i) {\n            let highlight_start_col = diagnostic.span.start_line == i ? diagnostic.span.start_column :\n                diagnostic.span.start_line < i ? 0 : null;\n            let highlight_end_col = diagnostic.span.end_line == i ? diagnostic.span.end_column :\n                diagnostic.span.end_line < i ? null : -1;\n            view.appendChild(make_line_view(source_lines, i, highlight_start_col, highlight_end_col));\n        }\n        div.appendChild(view);\n    }\n    if (diagnostic.explanation) {\n        let explanation = document.createElement('p');\n        explanation.className = 'error_explanation';\n        explanation.innerHTML = diagnostic.explanation;\n        div.appendChild(explanation);\n    }\n    errors_div.appendChild(div);\n}\nexports.report = report;\n\n\n//# sourceURL=webpack://thing/./build/ts/diagnostics.js?");

/***/ }),

/***/ "./build/ts/lexer.js":
/*!***************************!*\
  !*** ./build/ts/lexer.js ***!
  \***************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.lex = void 0;\nconst diagnostics = __importStar(__webpack_require__(/*! ./diagnostics */ \"./build/ts/diagnostics.js\"));\nclass BadCharacter {\n    constructor(ch) {\n        this.ch = ch;\n        this.message = `bad character: ${ch}`;\n        this.explanation = null;\n    }\n}\nclass UnterminatedString {\n    constructor() { this.message = \"unterminated string\"; this.explanation = null; }\n}\nclass Lexer {\n    constructor(source) {\n        this.source = source;\n        this.source = source;\n        this.ind = 0;\n    }\n    lex() {\n        let tokens = [];\n        while (!this.at_end()) {\n            let tok_start = this.ind;\n            let tok = this.lex_single_token(tok_start);\n            let tok_end = this.ind;\n            if (tok != null) {\n                tokens.push(Object.assign({ span: new diagnostics.Span(this.source, tok_start, tok_end) }, tok));\n            }\n        }\n        let eof = Object.assign(Object.assign({}, { type: \"eof\" }), { span: this.span(this.ind) });\n        return [tokens, eof];\n    }\n    lex_single_token(start_ind) {\n        let c = this.advance();\n        if (c == null) {\n            return null;\n        }\n        switch (c) {\n            case '(': return { type: \"'('\" };\n            case ')': return { type: \"')'\" };\n            case ',': return { type: \"','\" };\n            case '.': return { type: \"'.'\" };\n            case '+': return { type: \"'+'\" };\n            case '-': return { type: \"'-'\" };\n            case '*': return { type: \"'*'\" };\n            case '/':\n                if (this.match('/')) {\n                    while (!this.at_end() && this.peek() != '\\n') {\n                        this.advance();\n                    }\n                    ;\n                    return null;\n                }\n                else {\n                    return { type: \"'/'\" };\n                }\n            case '{': return { type: \"'{'\" };\n            case '}': return { type: \"'}'\" };\n            case ';': return { type: \"';'\" };\n            case ' ':\n            case '\\n':\n            case '\\r':\n            case '\\t':\n                return null;\n            case '!': return this.match('=') ? { type: \"'!='\" } : { type: \"'!'\" };\n            case '=': return this.match('=') ? { type: \"'=='\" } : { type: \"'='\" };\n            case '<': return this.match('=') ? { type: \"'<='\" } : { type: \"'<'\" };\n            case '>': return this.match('=') ? { type: \"'>='\" } : { type: \"'>'\" };\n            case '\"': return this.string(start_ind);\n            default:\n                if (this.is_digit(c)) {\n                    return this.number();\n                }\n                else if (this.is_alpha(c)) {\n                    return this.identifier();\n                }\n                else {\n                    diagnostics.report(Object.assign(Object.assign({}, new BadCharacter(c)), { span: this.span(start_ind) }));\n                    return null;\n                }\n        }\n    }\n    string(start_ind) {\n        let lit_start = this.ind;\n        while (!this.at_end() && this.peek() != '\"') {\n            this.advance();\n        }\n        if (this.at_end()) {\n            diagnostics.report(Object.assign(Object.assign({}, new UnterminatedString()), { span: this.span(start_ind) }));\n            return null;\n        }\n        let lit_end = this.ind;\n        this.advance();\n        let value = this.source.substring(lit_start, lit_end);\n        return { type: \"string literal\", str: value };\n    }\n    number() {\n        let start = this.ind - 1;\n        while (this.is_digit_(this.peek())) {\n            this.advance();\n        }\n        if (this.peek() == '.' && this.is_digit_(this.double_peek())) {\n            this.advance();\n            while (this.is_digit_(this.peek()))\n                this.advance();\n        }\n        return { type: \"number literal\", num: parseFloat(this.source.substring(start, this.ind)) };\n    }\n    identifier() {\n        let start = this.ind - 1;\n        while (this.is_alphanumeric_(this.peek())) {\n            this.advance();\n        }\n        let str = this.source.substring(start, this.ind);\n        switch (str) {\n            case \"and\": return { type: \"'and'\" };\n            case \"class\": return { type: \"'class'\" };\n            case \"else\": return { type: \"'else'\" };\n            case \"false\": return { type: \"bool literal\", bool: false };\n            case \"for\": return { type: \"'for'\" };\n            case \"fun\": return { type: \"'fun'\" };\n            case \"if\": return { type: \"'if'\" };\n            case \"nil\": return { type: \"'nil'\" };\n            case \"or\": return { type: \"'or'\" };\n            case \"print\": return { type: \"'print'\" };\n            case \"return\": return { type: \"'return'\" };\n            case \"super\": return { type: \"'super'\" };\n            case \"this\": return { type: \"'this'\" };\n            case \"true\": return { type: \"bool literal\", bool: true };\n            case \"var\": return { type: \"'var'\" };\n            case \"while\": return { type: \"'while'\" };\n            default: return { type: \"identifier\", name: str };\n        }\n    }\n    is_digit(x) {\n        return /\\d/.test(x);\n    }\n    is_digit_(x) {\n        if (x == null) {\n            return false;\n        }\n        return /\\d/.test(x);\n    }\n    is_alpha(x) {\n        return /[a-zA-Z]/.test(x);\n    }\n    is_alphanumeric(x) {\n        return this.is_digit(x) || this.is_alpha(x);\n    }\n    is_alphanumeric_(x) {\n        if (x == null) {\n            return false;\n        }\n        return this.is_digit(x) || this.is_alpha(x);\n    }\n    at_end() {\n        return this.ind >= this.source.length;\n    }\n    peek() {\n        if (this.at_end()) {\n            return null;\n        }\n        else {\n            return this.source[this.ind];\n        }\n    }\n    double_peek() {\n        if (this.ind + 1 >= this.source.length) {\n            return null;\n        }\n        else {\n            return this.source[this.ind + 1];\n        }\n    }\n    advance() {\n        if (this.at_end()) {\n            return null;\n        }\n        else {\n            return this.source[this.ind++];\n        }\n    }\n    match(x) {\n        if (this.peek() == x) {\n            this.advance();\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    span(start) {\n        return new diagnostics.Span(this.source, start, this.ind);\n    }\n}\nfunction lex(input) {\n    return new Lexer(input).lex();\n}\nexports.lex = lex;\n\n\n//# sourceURL=webpack://thing/./build/ts/lexer.js?");

/***/ }),

/***/ "./build/ts/main.js":
/*!**************************!*\
  !*** ./build/ts/main.js ***!
  \**************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst diagnostics = __importStar(__webpack_require__(/*! ./diagnostics */ \"./build/ts/diagnostics.js\"));\nconst bytecode = __importStar(__webpack_require__(/*! ./bytecode */ \"./build/ts/bytecode.js\"));\nconst lexer = __importStar(__webpack_require__(/*! ./lexer */ \"./build/ts/lexer.js\"));\nconst parser = __importStar(__webpack_require__(/*! ./parser */ \"./build/ts/parser.js\"));\nconst compiler = __importStar(__webpack_require__(/*! ./compiler */ \"./build/ts/compiler.js\"));\nconst vm = __importStar(__webpack_require__(/*! ./vm */ \"./build/ts/vm.js\"));\nlet editor = ace.edit(\"codeeditor\");\neditor.setOption(\"printMarginColumn\", false);\ndocument.getElementById('submitbutton').addEventListener('click', function () {\n    let inputcodebox = document.getElementById('inputcodebox');\n    let input = editor.getValue();\n    diagnostics.clear();\n    let lexed = lexer.lex(input);\n    let parsed = parser.parse(lexed);\n    if (parsed) {\n        let compiled = compiler.compile(parsed);\n        vm.interpret(compiled);\n        let ppc = new bytecode.PrettyPrintContext();\n        ppc.pretty_print_instrs(compiled);\n        document.getElementById('compiledcodeview').textContent = ppc.result;\n        console.log(compiled);\n        console.log(ppc.result);\n    }\n});\n\n\n//# sourceURL=webpack://thing/./build/ts/main.js?");

/***/ }),

/***/ "./build/ts/parser.js":
/*!****************************!*\
  !*** ./build/ts/parser.js ***!
  \****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parse = void 0;\nconst diagnostics = __importStar(__webpack_require__(/*! ./diagnostics */ \"./build/ts/diagnostics.js\"));\nconst ast = __importStar(__webpack_require__(/*! ./ast */ \"./build/ts/ast.js\"));\nconst peg = __importStar(__webpack_require__(/*! ./peg */ \"./build/ts/peg.js\"));\nfunction astify_binary_expr([comp, ops]) {\n    let cur;\n    while (cur = ops.shift()) {\n        let [op, right] = cur;\n        let op_ast;\n        switch (op.type) {\n            case \"'+'\":\n                op_ast = ast.BinaryOperator.Plus;\n                break;\n            case \"'-'\":\n                op_ast = ast.BinaryOperator.Minus;\n                break;\n            case \"'*'\":\n                op_ast = ast.BinaryOperator.Star;\n                break;\n            case \"'/'\":\n                op_ast = ast.BinaryOperator.Slash;\n                break;\n            case \"'<'\":\n                op_ast = ast.BinaryOperator.Less;\n                break;\n            case \"'>'\":\n                op_ast = ast.BinaryOperator.Greater;\n                break;\n            case \"'<='\":\n                op_ast = ast.BinaryOperator.LessEqual;\n                break;\n            case \"'=='\":\n                op_ast = ast.BinaryOperator.EqualEqual;\n                break;\n            case \"'>='\":\n                op_ast = ast.BinaryOperator.GreaterEqual;\n                break;\n            case \"'!='\":\n                op_ast = ast.BinaryOperator.BangEqual;\n                break;\n        }\n        comp = { type: 'BinaryExpr', span: diagnostics.join_spans(comp.span, right.span), left: comp, right, op: op_ast };\n    }\n    return comp;\n}\nfunction astify_logic_expr([comp, ops]) {\n    let cur;\n    while (cur = ops.shift()) {\n        let [op, right] = cur;\n        let op_ast;\n        switch (op.type) {\n            case \"'and'\":\n                op_ast = ast.LogicalOperator.And;\n                break;\n            case \"'or'\":\n                op_ast = ast.LogicalOperator.Or;\n                break;\n        }\n        comp = { type: 'LogicalExpr', span: diagnostics.join_spans(comp.span, right.span), left: comp, right, op: op_ast };\n    }\n    return comp;\n}\nlet block;\nlet expression;\nlet expression_indirect = () => expression;\nlet args = new peg.Indirect(expression_indirect).chain(new peg.ZeroMore(new peg.Token(\"','\").chain(new peg.Indirect(expression_indirect)))).apply(([first, more]) => [first].concat(more.map(x => x[1])));\nlet params = new peg.Token(\"identifier\").chain(new peg.ZeroMore(new peg.Token(\"','\").chain(new peg.Token(\"identifier\")))).apply(([first, more]) => [first].concat(more.map(x => x[1])));\nlet fn = new peg.Token(\"identifier\").chain(new peg.Token(\"'('\")).chain(new peg.Optional(params)).chain(new peg.Token(\"')'\")).chain(new peg.Indirect(() => block))\n    .apply(([[[[identifier, oparen], params], cparen], block]) => [identifier, params ? params : [], block]);\nlet primary = new peg.Token('bool literal').apply(tok => ({ type: 'BoolLiteral', span: tok.span, value: tok.bool })).choice(new peg.Token(\"'nil'\").apply(tok => ({ type: 'NilLiteral', span: tok.span }))).choice(new peg.Token('number literal').apply(tok => ({ type: 'NumberLiteral', span: tok.span, value: tok.num }))).choice(new peg.Token('string literal').apply(tok => ({ type: 'StringLiteral', span: tok.span, value: tok.str }))).choice(new peg.Token(\"identifier\").apply(ident => ({ type: 'VarExpr', span: ident.span, name: ident.name }))).choice(new peg.Token(\"'('\").chain(new peg.Indirect(expression_indirect)).chain(new peg.Token(\"')'\")).apply(([[oparen, expr], cparen]) => expr)); // TODO: track parenthesized expressions\nlet call = primary.chain(new peg.ZeroMore(new peg.Choice(new peg.Token(\"'('\").chain(new peg.Optional(args)).chain(new peg.Token(\"')'\")).apply(([[oparen, args], cparen]) => { let x = [args, cparen]; return x; }), new peg.Token(\"'.'\").chain(new peg.Token(\"identifier\")).apply(([dot, ident]) => ident)))).apply(([expr, ops]) => {\n    let cur_op;\n    while (cur_op = ops.shift()) {\n        if (!Array.isArray(cur_op)) {\n            let ident = cur_op;\n            // expr =\n            throw new Error(\"not implemented yet\"); // TODO\n        }\n        else {\n            let a;\n            if (cur_op[0]) {\n                a = cur_op[0];\n            }\n            else {\n                a = [];\n            }\n            expr = { type: 'CallExpr', span: diagnostics.join_spans(expr.span, cur_op[1].span), callee: expr, args: a };\n        }\n    }\n    return expr;\n});\nlet unary;\nunary =\n    (new peg.Token(\"'-'\").choice(new peg.Token(\"'!'\"))).chain(new peg.Indirect(() => unary)).apply(([op, expr]) => {\n        let op_ast;\n        switch (op.type) {\n            case \"'-'\":\n                op_ast = ast.UnaryOperator.Minus;\n                break;\n            case \"'!'\":\n                op_ast = ast.UnaryOperator.Bang;\n                break;\n            default: throw Error('unreachable');\n        }\n        return { type: 'UnaryExpr', span: diagnostics.join_spans(op.span, expr.span), operator: op_ast, operand: expr };\n    })\n        .choice(call);\nlet factor = new peg.Apply(astify_binary_expr, new peg.Chain(unary, new peg.ZeroMore(new peg.Chain(new peg.Choice(new peg.Token(\"'*'\"), new peg.Token(\"'/'\")), unary))));\nlet term = new peg.Apply(astify_binary_expr, new peg.Chain(factor, new peg.ZeroMore(new peg.Chain(new peg.Choice(new peg.Token(\"'+'\"), new peg.Token(\"'-'\")), factor))));\nlet comparison = new peg.Apply(astify_binary_expr, new peg.Chain(term, new peg.ZeroMore(new peg.Chain(new peg.Choice(new peg.Choice(new peg.Choice(new peg.Token(\"'<'\"), new peg.Token(\"'<='\")), new peg.Token(\"'>'\")), new peg.Token(\"'>='\")), term))));\nlet equality = new peg.Apply(astify_binary_expr, new peg.Chain(comparison, new peg.ZeroMore(new peg.Chain(new peg.Choice(new peg.Token(\"'=='\"), new peg.Token(\"'!='\")), comparison))));\nlet logic_and = equality.chain(new peg.ZeroMore(new peg.Token(\"'and'\").chain(equality))).apply(astify_logic_expr);\nlet logic_or = logic_and.chain(new peg.ZeroMore(new peg.Token(\"'or'\").chain(logic_and))).apply(astify_logic_expr);\nlet assignment;\nassignment =\n    new peg.Optional(call.chain(new peg.Token(\"'.'\"))).chain(new peg.Token(\"identifier\")).chain(new peg.Token(\"'='\")).chain(new peg.Indirect(() => assignment))\n        .apply(([[[m_call, ident], eq], assignment]) => ({ type: 'AssignExpr', span: diagnostics.join_spans(m_call ? m_call[0].span : ident.span, assignment.span), name: ident.name, value: assignment }))\n        .choice(logic_or);\nexpression = assignment;\nlet expr_stmt = new peg.Apply(([expr, semi]) => ({ type: 'ExprStmt', span: diagnostics.join_spans(expr.span, semi.span), expr }), new peg.Chain(new peg.Indirect(expression_indirect), new peg.Token(\"';'\")));\nlet print_stmt = new peg.Apply(([[print, expr], semi]) => ({ type: 'PrintStmt', span: diagnostics.join_spans(print.span, semi.span), expr }), new peg.Chain(new peg.Chain(new peg.Token(\"'print'\"), new peg.Indirect(expression_indirect)), new peg.Token(\"';'\")));\nlet var_decl;\nlet statement;\nlet statement_indirect = () => statement;\nlet declaration;\nlet declaration_indirect = () => declaration;\nlet for_stmt = new peg.Chain(new peg.Chain(new peg.Chain(new peg.Chain(new peg.Chain(new peg.Chain(new peg.Token(\"'for'\"), new peg.Token(\"'('\")), new peg.Choice(new peg.Choice(new peg.Indirect(() => var_decl), expr_stmt), new peg.Token(\"';'\").apply(() => null))), new peg.Chain(new peg.Optional(new peg.Indirect(expression_indirect)), new peg.Token(\"';'\"))), new peg.Optional(new peg.Indirect(expression_indirect))), new peg.Token(\"')'\")), new peg.Indirect(statement_indirect))\n    .apply(([[[[[[for_, oparen], initializer], cond], inc], cparen], body]) => {\n    return { type: 'ForStmt', span: diagnostics.join_spans(for_.span, body.span), initializer, compare: cond[0], increment: inc, body, for_sp: for_.span };\n});\nlet if_stmt = new peg.Apply(([[[[[if_, oparen], cond], cparen], body], m_else]) => ({ type: 'IfStmt', span: diagnostics.join_spans(if_.span, m_else ? m_else[1].span : body.span), condition: cond, then_branch: body, else_branch: m_else ? m_else[1] : null }), new peg.Chain(new peg.Chain(new peg.Chain(new peg.Chain(new peg.Chain(new peg.Token(\"'if'\"), new peg.Token(\"'('\")), new peg.Indirect(expression_indirect)), new peg.Token(\"')'\")), new peg.Indirect(statement_indirect)), new peg.Optional(new peg.Chain(new peg.Token(\"'else'\"), new peg.Indirect(statement_indirect)))));\nlet return_stmt = new peg.Apply(([[return_, m_expr], semi]) => ({ type: 'ReturnStmt', span: diagnostics.join_spans(return_.span, semi.span), value: m_expr }), new peg.Chain(new peg.Chain(new peg.Token(\"'return'\"), new peg.Optional(new peg.Indirect(expression_indirect))), new peg.Token(\"';'\")));\nlet while_stmt = new peg.Apply(([[[[while_, oparen], cond], cparen], body]) => ({ type: 'WhileStmt', span: diagnostics.join_spans(while_.span, body.span), condition: cond, body }), new peg.Chain(new peg.Chain(new peg.Chain(new peg.Chain(new peg.Token(\"'while'\"), new peg.Token(\"'('\")), new peg.Indirect(expression_indirect)), new peg.Token(\"')'\")), new peg.Indirect(statement_indirect)));\nblock =\n    new peg.Apply(([[obrace, stmts], cbrace]) => ({ type: 'BlockStmt', span: diagnostics.join_spans(obrace.span, cbrace.span), stmts, obrace_sp: obrace.span, cbrace_sp: cbrace.span }), new peg.Chain(new peg.Chain(new peg.Token(\"'{'\"), new peg.ZeroMore(new peg.Indirect(declaration_indirect))), new peg.Token(\"'}'\")));\nstatement =\n    expr_stmt\n        .choice(print_stmt)\n        .choice(for_stmt)\n        .choice(if_stmt)\n        .choice(return_stmt)\n        .choice(while_stmt)\n        .choice(block);\nvar_decl =\n    new peg.Apply(([[[var_, ident], m_initializer], semi]) => ({ type: 'VarStmt', span: diagnostics.join_spans(var_.span, semi.span), name: ident.name, initializer: m_initializer ? m_initializer[1] : null }), new peg.Chain(new peg.Chain(new peg.Chain(new peg.Token(\"'var'\"), new peg.Token(\"identifier\")), new peg.Optional(new peg.Chain(new peg.Token(\"'='\"), new peg.Indirect(expression_indirect)))), new peg.Token(\"';'\")));\nlet fun_decl = new peg.Chain(new peg.Token(\"'fun'\"), fn).apply(([fun, [identifier, params, block]]) => ({ type: 'FunctionStmt', span: diagnostics.join_spans(fun.span, block.span), name: identifier.name, params: params.map(x => x.name), body: block }));\ndeclaration = new peg.Choice(new peg.Choice(fun_decl, var_decl), statement);\nlet script = new peg.Apply(([stmts, eof]) => stmts, new peg.Chain(new peg.ZeroMore(declaration), new peg.Token(\"eof\")));\nfunction parse([tokens, eof]) {\n    let parser = new peg.Parser(tokens, eof);\n    let location = new peg.ParseLocation(parser, 0);\n    let res = script.parse(parser, location);\n    if (res) {\n        return res[1];\n    }\n    else {\n        parser.report_error();\n        return null;\n    }\n}\nexports.parse = parse;\n\n\n//# sourceURL=webpack://thing/./build/ts/parser.js?");

/***/ }),

/***/ "./build/ts/peg.js":
/*!*************************!*\
  !*** ./build/ts/peg.js ***!
  \*************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Indirect = exports.Apply = exports.OneMore = exports.ZeroMore = exports.Optional = exports.Choice = exports.Chain = exports.Token = exports.PEG = exports.ParseLocation = exports.Parser = void 0;\nconst diagnostics = __importStar(__webpack_require__(/*! ./diagnostics */ \"./build/ts/diagnostics.js\"));\nclass Parser {\n    constructor(tokens, eof) {\n        this.tokens = tokens;\n        this.eof = eof;\n        this.errors = new Map();\n    }\n    error(ind, expect) {\n        if (!this.errors.has(ind)) {\n            this.errors.set(ind, []);\n        }\n        this.errors.get(ind).push(expect);\n    }\n    report_error() {\n        let max_ind = Math.max(...this.errors.keys());\n        let got = this.get_tok(max_ind);\n        let es = this.errors.get(max_ind);\n        let explanation;\n        if (es.length == 1) {\n            explanation = `expected ${es[0]}, got ${got.type}`;\n        }\n        else {\n            explanation = `expected one of ${es}, got ${got.type}`;\n        }\n        diagnostics.report({\n            message: `parse error: ${explanation}`,\n            explanation: null,\n            span: got.span,\n        });\n    }\n    get_tok(ind) {\n        if (ind >= this.tokens.length) {\n            return this.eof;\n        }\n        else {\n            return this.tokens[ind];\n        }\n    }\n}\nexports.Parser = Parser;\nclass ParseLocation {\n    constructor(parser, ind) {\n        this.parser = parser;\n        this.ind = ind;\n    }\n    advance() {\n        return new ParseLocation(this.parser, this.ind + 1);\n    }\n    tok() { return this.parser.get_tok(this.ind); }\n}\nexports.ParseLocation = ParseLocation;\nclass PEG {\n    // convenience methods\n    chain(other) {\n        return new Chain(this, other);\n    }\n    choice(other) {\n        return new Choice(this, other);\n    }\n    apply(op) {\n        return new Apply(op, this);\n    }\n}\nexports.PEG = PEG;\nclass Token extends PEG {\n    constructor(type) {\n        super();\n        this.type = type;\n    }\n    parse(parser, location) {\n        let t = location.tok();\n        if (t.type == this.type) {\n            return [location.advance(), t];\n        }\n        else {\n            parser.error(location.ind, this.type);\n            return null;\n        }\n    }\n}\nexports.Token = Token;\nclass Chain extends PEG {\n    constructor(a, b) {\n        super();\n        this.a = a;\n        this.b = b;\n    }\n    parse(parser, location) {\n        let m_a_res = this.a.parse(parser, location);\n        if (m_a_res) {\n            let [location_, a_res] = m_a_res;\n            let m_b_res = this.b.parse(parser, location_);\n            if (m_b_res) {\n                let [location__, b_res] = m_b_res;\n                return [location__, [a_res, b_res]];\n            }\n        }\n        return null;\n    }\n}\nexports.Chain = Chain;\nclass Choice extends PEG {\n    constructor(a, b) {\n        super();\n        this.a = a;\n        this.b = b;\n    }\n    parse(parser, location) {\n        let m_a_res = this.a.parse(parser, location);\n        if (m_a_res) {\n            return m_a_res;\n        }\n        else {\n            let m_b_res = this.b.parse(parser, location);\n            if (m_b_res) {\n                return m_b_res;\n            }\n        }\n        return null;\n    }\n}\nexports.Choice = Choice;\nclass Optional extends PEG {\n    constructor(a) {\n        super();\n        this.a = a;\n    }\n    parse(parser, location) {\n        let m_a_res = this.a.parse(parser, location);\n        if (m_a_res) {\n            let [location_, a_res] = m_a_res;\n            return [location_, a_res];\n        }\n        else {\n            return [location, null];\n        }\n    }\n}\nexports.Optional = Optional;\nclass ZeroMore extends PEG {\n    constructor(a) {\n        super();\n        this.a = a;\n    }\n    parse(parser, location) {\n        let items = [];\n        while (true) {\n            let m_res = this.a.parse(parser, location);\n            if (m_res) {\n                let [location_, item] = m_res;\n                location = location_;\n                items.push(item);\n            }\n            else {\n                return [location, items];\n            }\n        }\n    }\n}\nexports.ZeroMore = ZeroMore;\nclass OneMore extends PEG {\n    constructor(a) {\n        super();\n        this.a = a;\n    }\n    parse(parser, location) {\n        return new Apply(([first, more]) => [first].concat(more), new Chain(this.a, new ZeroMore(this.a))).parse(parser, location);\n    }\n}\nexports.OneMore = OneMore;\nclass Apply extends PEG {\n    constructor(op, a) {\n        super();\n        this.op = op;\n        this.a = a;\n    }\n    parse(parser, location) {\n        let m_a_res = this.a.parse(parser, location);\n        if (m_a_res) {\n            let [location_, a_res] = m_a_res;\n            let b_res = this.op(a_res);\n            return [location_, b_res];\n        }\n        return null;\n    }\n}\nexports.Apply = Apply;\nclass Indirect extends PEG {\n    constructor(thing) {\n        super();\n        this.thing = thing;\n    }\n    parse(parser, location) {\n        return this.thing().parse(parser, location);\n    }\n}\nexports.Indirect = Indirect;\n\n\n//# sourceURL=webpack://thing/./build/ts/peg.js?");

/***/ }),

/***/ "./build/ts/runtime.js":
/*!*****************************!*\
  !*** ./build/ts/runtime.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Bool = exports.Number = exports.String = exports.Function = exports.Nil = exports.Register = exports.Environment = void 0;\nclass Environment {\n    constructor(parent) {\n        this.parent = parent;\n        this.registers = [];\n        this.variables = new Map();\n    }\n    get_register(index) {\n        if (index >= this.registers.length) {\n            throw new Error('internal error: get register that doesn\\'t exist'); // TODO: new runtime error class to catch\n        }\n        else {\n            return this.registers[index];\n        }\n    }\n    put_register(index, value) {\n        this.registers[index] = value;\n    }\n    get_variable(name) {\n        if (!this.variables.has(name))\n            throw new Error(`get variable that does not exist: '${name}'`); // TODO: new runtime error class to catch\n        else\n            return this.variables.get(name);\n    }\n    set_variable(name, value) {\n        if (!this.variables.has(name))\n            throw new Error(`set variable that does not exist: '${name}'`); // TODO: new runtime error class to catch\n        else\n            this.variables.set(name, value);\n    }\n    put_variable(name, value) {\n        this.variables.set(name, value);\n    }\n}\nexports.Environment = Environment;\nclass Register {\n    constructor(index) {\n        this.index = index;\n    }\n    pretty_print() { return `%${this.index}`; }\n    to_runtime_value(env) {\n        return env.get_register(this.index);\n    }\n}\nexports.Register = Register;\nclass Nil {\n    constructor() { }\n    pretty_print() { return 'nil'; }\n    to_runtime_value() { return this; }\n    is_truthy() { return false; }\n}\nexports.Nil = Nil;\nclass Function {\n    constructor(name, params, instructions) {\n        this.name = name;\n        this.params = params;\n        this.instructions = instructions;\n    }\n    pretty_print() { return `<function '${this.name}'>`; }\n    to_runtime_value() { return this; }\n    is_truthy() { return true; }\n}\nexports.Function = Function;\nclass String {\n    constructor(x) {\n        this.x = x;\n    }\n    pretty_print() { return `\"${this.x}\"`; }\n    to_runtime_value() { return this; }\n    is_truthy() { return true; }\n}\nexports.String = String;\nclass Number {\n    constructor(x) {\n        this.x = x;\n    }\n    pretty_print() { return this.x.toString(); }\n    to_runtime_value() { return this; }\n    is_truthy() { return true; }\n}\nexports.Number = Number;\nclass Bool {\n    constructor(x) {\n        this.x = x;\n    }\n    pretty_print() { return this.x.toString(); }\n    to_runtime_value() { return this; }\n    is_truthy() { return this.x; }\n}\nexports.Bool = Bool;\n\n\n//# sourceURL=webpack://thing/./build/ts/runtime.js?");

/***/ }),

/***/ "./build/ts/vm.js":
/*!************************!*\
  !*** ./build/ts/vm.js ***!
  \************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.interpret = void 0;\nconst bytecode = __importStar(__webpack_require__(/*! ./bytecode */ \"./build/ts/bytecode.js\"));\nconst runtime = __importStar(__webpack_require__(/*! ./runtime */ \"./build/ts/runtime.js\"));\nclass InstructionLister {\n    constructor(env) {\n        this.env = env;\n    }\n    *visitStmtMarker(instr) { yield instr; }\n    *visitUnaryOp(instr) { yield instr; }\n    *visitBinaryOp(instr) { yield instr; }\n    *visitCall(instr) { yield instr; }\n    *visitAssign(instr) { yield instr; }\n    *visitReadVar(instr) { yield instr; }\n    *visitEndScope(instr) { yield instr; }\n    *visitStartScope(instr) { yield instr; }\n    *visitReturn(instr) { yield instr; }\n    *visitIf(instr) {\n        if (instr.cond.to_runtime_value(this.env).is_truthy()) {\n            yield* instruction_list(this.env, instr.true_branch);\n        }\n        else {\n            if (instr.false_branch) {\n                yield* instruction_list(this.env, instr.false_branch);\n            }\n        }\n    }\n    *visitWhile(instr) {\n        while (true) {\n            yield* instruction_list(this.env, instr.check_code);\n            if (!instr.check.to_runtime_value(this.env).is_truthy())\n                break;\n            yield* instruction_list(this.env, instr.body_code);\n        }\n    }\n    *visitMakeVar(instr) { yield instr; }\n    *visitPrint(instr) { yield instr; }\n}\nfunction* instruction_list(env, instructions) {\n    for (let instr of instructions) {\n        yield* instr.accept(new InstructionLister(env));\n    }\n}\nfunction interpret(instructions) {\n    let env = new runtime.Environment(null);\n    for (let instr of instruction_list(env, instructions)) {\n        let ppc = new bytecode.PrettyPrintContext();\n        instr.pretty_print(ppc);\n        console.log(ppc.result);\n    }\n}\nexports.interpret = interpret;\n\n\n//# sourceURL=webpack://thing/./build/ts/vm.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./build/ts/main.js");
/******/ 	
/******/ })()
;
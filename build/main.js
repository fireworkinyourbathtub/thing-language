/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./build/ts/ast.js":
/*!*************************!*\
  !*** ./build/ts/ast.js ***!
  \*************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WhileStmt = exports.ReturnStmt = exports.IfStmt = exports.ForStmt = exports.FunctionStmt = exports.BlockStmt = exports.VarStmt = exports.PrintStmt = exports.ExprStmt = exports.Stmt = exports.ThisExpr = exports.SetExpr = exports.LogicalExpr = exports.GetExpr = exports.CallExpr = exports.AssignExpr = exports.Literal = exports.VarExpr = exports.UnaryExpr = exports.BinaryExpr = exports.LogicalOperator = exports.UnaryOperator = exports.BinaryOperator = exports.Expr = exports.AST = void 0;\nclass AST {\n    thing() { }\n}\nexports.AST = AST;\nclass Expr extends AST {\n}\nexports.Expr = Expr;\nvar BinaryOperator;\n(function (BinaryOperator) {\n    BinaryOperator[BinaryOperator[\"Plus\"] = 0] = \"Plus\";\n    BinaryOperator[BinaryOperator[\"Minus\"] = 1] = \"Minus\";\n    BinaryOperator[BinaryOperator[\"Star\"] = 2] = \"Star\";\n    BinaryOperator[BinaryOperator[\"Slash\"] = 3] = \"Slash\";\n    BinaryOperator[BinaryOperator[\"Less\"] = 4] = \"Less\";\n    BinaryOperator[BinaryOperator[\"Equal\"] = 5] = \"Equal\";\n    BinaryOperator[BinaryOperator[\"Greater\"] = 6] = \"Greater\";\n    BinaryOperator[BinaryOperator[\"Bang\"] = 7] = \"Bang\";\n    BinaryOperator[BinaryOperator[\"LessEqual\"] = 8] = \"LessEqual\";\n    BinaryOperator[BinaryOperator[\"EqualEqual\"] = 9] = \"EqualEqual\";\n    BinaryOperator[BinaryOperator[\"GreaterEqual\"] = 10] = \"GreaterEqual\";\n    BinaryOperator[BinaryOperator[\"BangEqual\"] = 11] = \"BangEqual\";\n})(BinaryOperator = exports.BinaryOperator || (exports.BinaryOperator = {}));\nvar UnaryOperator;\n(function (UnaryOperator) {\n    UnaryOperator[UnaryOperator[\"Minus\"] = 0] = \"Minus\";\n    UnaryOperator[UnaryOperator[\"Bang\"] = 1] = \"Bang\";\n})(UnaryOperator = exports.UnaryOperator || (exports.UnaryOperator = {}));\nvar LogicalOperator;\n(function (LogicalOperator) {\n    LogicalOperator[LogicalOperator[\"And\"] = 0] = \"And\";\n    LogicalOperator[LogicalOperator[\"Or\"] = 1] = \"Or\";\n})(LogicalOperator = exports.LogicalOperator || (exports.LogicalOperator = {}));\nclass BinaryExpr extends Expr {\n    constructor(left, right, op) {\n        super();\n        this.left = left;\n        this.right = right;\n        this.op = op;\n    }\n}\nexports.BinaryExpr = BinaryExpr;\nclass UnaryExpr extends Expr {\n    constructor(operator, operand) {\n        super();\n        this.operator = operator;\n        this.operand = operand;\n    }\n}\nexports.UnaryExpr = UnaryExpr;\nclass VarExpr extends Expr {\n    constructor(name) {\n        super();\n        this.name = name;\n    }\n}\nexports.VarExpr = VarExpr;\nclass Literal extends Expr {\n    constructor(value) {\n        super();\n        this.value = value;\n    }\n}\nexports.Literal = Literal;\nclass AssignExpr extends Expr {\n    constructor(name, value) {\n        super();\n        this.name = name;\n    }\n}\nexports.AssignExpr = AssignExpr;\nclass CallExpr extends Expr {\n    constructor(callee, args) {\n        super();\n        this.callee = callee;\n        this.args = args;\n    }\n}\nexports.CallExpr = CallExpr;\nclass GetExpr extends Expr {\n    constructor(object, name) {\n        super();\n        this.object = object;\n        this.name = name;\n    }\n}\nexports.GetExpr = GetExpr;\nclass LogicalExpr extends Expr {\n    constructor(left, operator, right) {\n        super();\n        this.left = left;\n        this.operator = operator;\n        this.right = right;\n    }\n}\nexports.LogicalExpr = LogicalExpr;\nclass SetExpr extends Expr {\n    constructor(object, name, value) {\n        super();\n        this.object = object;\n        this.name = name;\n        this.value = value;\n    }\n}\nexports.SetExpr = SetExpr;\nclass ThisExpr extends Expr {\n    constructor(keyword) {\n        super();\n        this.keyword = keyword;\n    }\n}\nexports.ThisExpr = ThisExpr;\n// export class SuperExpr extends Expr {\n// constructor(keyword: Token, method: ) { super() }\n// }\nclass Stmt extends AST {\n}\nexports.Stmt = Stmt;\nclass ExprStmt extends Stmt {\n    constructor(expr) {\n        super();\n        this.expr = expr;\n    }\n}\nexports.ExprStmt = ExprStmt;\nclass PrintStmt extends Stmt {\n    constructor(expr) {\n        super();\n        this.expr = expr;\n    }\n}\nexports.PrintStmt = PrintStmt;\nclass VarStmt extends Stmt {\n    constructor(name, initializer) {\n        super();\n        this.name = name;\n        this.initializer = initializer;\n    }\n}\nexports.VarStmt = VarStmt;\nclass BlockStmt extends Stmt {\n    constructor(stmts) {\n        super();\n        this.stmts = stmts;\n    }\n}\nexports.BlockStmt = BlockStmt;\n// export class ClassStmt extends Stmt {\n// constructor(name: string, List<Stmt.Function> methods) { super() }\n// }\nclass FunctionStmt extends Stmt {\n    constructor(name, param, body) {\n        super();\n        this.name = name;\n        this.param = param;\n        this.body = body;\n    }\n}\nexports.FunctionStmt = FunctionStmt;\nclass ForStmt extends Stmt {\n    constructor(initializer, compare, increment, body) {\n        super();\n        this.initializer = initializer;\n        this.compare = compare;\n        this.increment = increment;\n        this.body = body;\n    }\n}\nexports.ForStmt = ForStmt;\nclass IfStmt extends Stmt {\n    constructor(condition, then_branch, else_branch) {\n        super();\n        this.condition = condition;\n        this.then_branch = then_branch;\n        this.else_branch = else_branch;\n    }\n}\nexports.IfStmt = IfStmt;\nclass ReturnStmt extends Stmt {\n    constructor(value) {\n        super();\n        this.value = value;\n    }\n}\nexports.ReturnStmt = ReturnStmt;\nclass WhileStmt extends Stmt {\n    constructor(condition, body) {\n        super();\n        this.condition = condition;\n        this.body = body;\n    }\n}\nexports.WhileStmt = WhileStmt;\n\n\n//# sourceURL=webpack://thing/./build/ts/ast.js?");

/***/ }),

/***/ "./build/ts/diagnostics.js":
/*!*********************************!*\
  !*** ./build/ts/diagnostics.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.report = exports.clear = exports.Diagnostic = exports.Located = exports.Span = void 0;\nconst errors_div = document.getElementById('errors');\nclass Span {\n    constructor(source, start, end) {\n        this.source = source;\n        this.start = start;\n        this.end = end;\n        [this.start_line, this.start_column] = get_linecol(source, start);\n        [this.end_line, this.end_column] = get_linecol(source, end);\n    }\n}\nexports.Span = Span;\nfunction get_linecol(source, ind) {\n    let line = (source.substring(0, ind).match(/^/mg) || []).length;\n    let lines = source.substring(0, ind).match(/^.+/mg);\n    if (lines) {\n        return [line, lines[lines.length - 1].length + 1];\n    }\n    else {\n        return [line, 0];\n    }\n}\nclass Located {\n    constructor(thing, span) {\n        this.thing = thing;\n        this.span = span;\n    }\n}\nexports.Located = Located;\nclass Diagnostic {\n    constructor(message, explanation) {\n        this.message = message;\n        this.explanation = explanation;\n    }\n}\nexports.Diagnostic = Diagnostic;\nfunction clear() {\n    while (errors_div.lastChild) {\n        errors_div.removeChild(errors_div.lastChild);\n    }\n}\nexports.clear = clear;\nfunction report(diagnostic) {\n    let div = document.createElement('div');\n    div.className = 'error';\n    {\n        let heading = document.createElement('p');\n        heading.className = 'error_heading';\n        heading.innerHTML = `error at ${diagnostic.span.start_line}:${diagnostic.span.start_column}: ${diagnostic.thing.message}`;\n        div.appendChild(heading);\n    }\n    {\n        function make_line_view(source, nr, highlight_start_col, highlight_end_col) {\n            let line_view = document.createElement('div');\n            line_view.className = 'error_line_view';\n            let line_number = document.createElement('p');\n            line_number.innerHTML = nr.toString();\n            line_number.className = 'error_linenumber';\n            let pre = document.createElement('pre');\n            let code = document.createElement('code');\n            pre.className = 'error_pre';\n            code.className = 'error_code';\n            if (highlight_start_col == null || highlight_end_col == null) {\n                code.innerHTML = source[nr - 1];\n            }\n            else {\n                let line_contents = source[nr - 1];\n                let start = highlight_start_col - 1;\n                let end = highlight_end_col == -1 ? line_contents.length : highlight_end_col - 1;\n                code.innerHTML = `${line_contents.substring(0, start)}<strong>${line_contents.substring(start, end)}</strong>${line_contents.substring(end)}`;\n            }\n            line_view.appendChild(line_number);\n            pre.appendChild(code);\n            line_view.appendChild(pre);\n            return line_view;\n        }\n        let view = document.createElement('div');\n        view.className = 'error_view';\n        let source_lines = diagnostic.span.source.split('\\n');\n        for (let i = diagnostic.span.start_line; i <= diagnostic.span.end_line; ++i) {\n            let highlight_start_col = diagnostic.span.start_line == i ? diagnostic.span.start_column :\n                diagnostic.span.start_line < i ? 0 : null;\n            let highlight_end_col = diagnostic.span.end_line == i ? diagnostic.span.end_column :\n                diagnostic.span.end_line < i ? null : -1;\n            view.appendChild(make_line_view(source_lines, i, highlight_start_col, highlight_end_col));\n        }\n        div.appendChild(view);\n    }\n    if (diagnostic.thing.explanation) {\n        let explanation = document.createElement('p');\n        explanation.className = 'error_explanation';\n        explanation.innerHTML = diagnostic.thing.explanation;\n        div.appendChild(explanation);\n    }\n    errors_div.appendChild(div);\n}\nexports.report = report;\n\n\n//# sourceURL=webpack://thing/./build/ts/diagnostics.js?");

/***/ }),

/***/ "./build/ts/lexer.js":
/*!***************************!*\
  !*** ./build/ts/lexer.js ***!
  \***************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.lex = exports.EOF = exports.BoolLiteral = exports.NumberLiteral = exports.StringLiteral = exports.Identifier = exports.While = exports.Var = exports.This = exports.Super = exports.Return = exports.Print = exports.Or = exports.Nil = exports.If = exports.Fun = exports.For = exports.Else = exports.Class = exports.And = exports.BangEqual = exports.GreaterEqual = exports.EqualEqual = exports.LessEqual = exports.Bang = exports.Greater = exports.Equal = exports.Less = exports.Semicolon = exports.CBrace = exports.OBrace = exports.Slash = exports.Star = exports.Minus = exports.Plus = exports.Dot = exports.Comma = exports.CParen = exports.OParen = exports.Token = void 0;\nconst diagnostics = __importStar(__webpack_require__(/*! ./diagnostics */ \"./build/ts/diagnostics.js\"));\nclass Token {\n}\nexports.Token = Token;\nclass OParen extends Token {\n    type() { return \"'('\"; }\n}\nexports.OParen = OParen;\nclass CParen extends Token {\n    type() { return \"')'\"; }\n}\nexports.CParen = CParen;\nclass Comma extends Token {\n    type() { return \"','\"; }\n}\nexports.Comma = Comma;\nclass Dot extends Token {\n    type() { return \"'.'\"; }\n}\nexports.Dot = Dot;\nclass Plus extends Token {\n    type() { return \"'+'\"; }\n}\nexports.Plus = Plus;\nclass Minus extends Token {\n    type() { return \"'-'\"; }\n}\nexports.Minus = Minus;\nclass Star extends Token {\n    type() { return \"'*'\"; }\n}\nexports.Star = Star;\nclass Slash extends Token {\n    type() { return \"'/'\"; }\n}\nexports.Slash = Slash;\nclass OBrace extends Token {\n    type() { return \"'{'\"; }\n}\nexports.OBrace = OBrace;\nclass CBrace extends Token {\n    type() { return \"'}'\"; }\n}\nexports.CBrace = CBrace;\nclass Semicolon extends Token {\n    type() { return \"';'\"; }\n}\nexports.Semicolon = Semicolon;\nclass Less extends Token {\n    type() { return \"'<'\"; }\n}\nexports.Less = Less;\nclass Equal extends Token {\n    type() { return \"'='\"; }\n}\nexports.Equal = Equal;\nclass Greater extends Token {\n    type() { return \"'>'\"; }\n}\nexports.Greater = Greater;\nclass Bang extends Token {\n    type() { return \"'!'\"; }\n}\nexports.Bang = Bang;\nclass LessEqual extends Token {\n    type() { return \"'<='\"; }\n}\nexports.LessEqual = LessEqual;\nclass EqualEqual extends Token {\n    type() { return \"'=='\"; }\n}\nexports.EqualEqual = EqualEqual;\nclass GreaterEqual extends Token {\n    type() { return \"'>='\"; }\n}\nexports.GreaterEqual = GreaterEqual;\nclass BangEqual extends Token {\n    type() { return \"'!='\"; }\n}\nexports.BangEqual = BangEqual;\nclass And extends Token {\n    type() { return \"'and'\"; }\n}\nexports.And = And;\nclass Class extends Token {\n    type() { return \"'class'\"; }\n}\nexports.Class = Class;\nclass Else extends Token {\n    type() { return \"'else'\"; }\n}\nexports.Else = Else;\nclass For extends Token {\n    type() { return \"'for'\"; }\n}\nexports.For = For;\nclass Fun extends Token {\n    type() { return \"'fun'\"; }\n}\nexports.Fun = Fun;\nclass If extends Token {\n    type() { return \"'if'\"; }\n}\nexports.If = If;\nclass Nil extends Token {\n    type() { return \"'nil'\"; }\n}\nexports.Nil = Nil;\nclass Or extends Token {\n    type() { return \"'or'\"; }\n}\nexports.Or = Or;\nclass Print extends Token {\n    type() { return \"'print'\"; }\n}\nexports.Print = Print;\nclass Return extends Token {\n    type() { return \"'return'\"; }\n}\nexports.Return = Return;\nclass Super extends Token {\n    type() { return \"'super'\"; }\n}\nexports.Super = Super;\nclass This extends Token {\n    type() { return \"'this'\"; }\n}\nexports.This = This;\nclass Var extends Token {\n    type() { return \"'var'\"; }\n}\nexports.Var = Var;\nclass While extends Token {\n    type() { return \"'while'\"; }\n}\nexports.While = While;\nclass Identifier extends Token {\n    constructor(name) {\n        super();\n        this.name = name;\n    }\n    type() { return \"identifier\"; }\n}\nexports.Identifier = Identifier;\nclass StringLiteral extends Token {\n    constructor(str) {\n        super();\n        this.str = str;\n    }\n    type() { return \"string literal\"; }\n}\nexports.StringLiteral = StringLiteral;\nclass NumberLiteral extends Token {\n    constructor(num) {\n        super();\n        this.num = num;\n    }\n    type() { return \"number literal\"; }\n}\nexports.NumberLiteral = NumberLiteral;\nclass BoolLiteral extends Token {\n    constructor(bool) {\n        super();\n        this.bool = bool;\n    }\n    type() { return \"bool literal\"; }\n}\nexports.BoolLiteral = BoolLiteral;\nclass EOF extends Token {\n    type() { return \"eof\"; }\n}\nexports.EOF = EOF;\nclass BadCharacter extends diagnostics.Diagnostic {\n    constructor(ch) {\n        super(`bad character: ${ch}`, null);\n        this.ch = ch;\n    }\n}\nclass UnterminatedString extends diagnostics.Diagnostic {\n    constructor() { super(\"unterminated string\", null); }\n}\nclass Lexer {\n    constructor(source) {\n        this.source = source;\n        this.source = source;\n        this.ind = 0;\n    }\n    lex() {\n        let tokens = [];\n        while (!this.at_end()) {\n            let tok_start = this.ind;\n            let tok = this.lex_single_token(tok_start);\n            let tok_end = this.ind;\n            if (tok != null) {\n                tokens.push(new diagnostics.Located(tok, new diagnostics.Span(this.source, tok_start, tok_end)));\n            }\n        }\n        let eof = new diagnostics.Located(new EOF(), this.span(this.ind));\n        return [tokens, eof];\n    }\n    lex_single_token(start_ind) {\n        let c = this.advance();\n        if (c == null) {\n            return null;\n        }\n        switch (c) {\n            case '(': return new OParen();\n            case ')': return new CParen();\n            case ',': return new Comma();\n            case '.': return new Dot();\n            case '+': return new Plus();\n            case '-': return new Minus();\n            case '*': return new Star();\n            case '/':\n                if (this.match('/')) {\n                    while (!this.at_end() && this.peek() != '\\n') {\n                        this.advance();\n                    }\n                    ;\n                    return null;\n                }\n                else {\n                    return new Slash();\n                }\n            case '{': return new OBrace();\n            case '}': return new CBrace();\n            case ';': return new Semicolon();\n            case ' ':\n            case '\\n':\n            case '\\r':\n            case '\\t':\n                return null;\n            case '!': return this.match('=') ? new BangEqual() : new Bang();\n            case '=': return this.match('=') ? new EqualEqual() : new Equal();\n            case '<': return this.match('=') ? new LessEqual() : new Less();\n            case '>': return this.match('=') ? new GreaterEqual() : new Greater();\n            case '\"': return this.string(start_ind);\n            default:\n                if (this.is_digit(c)) {\n                    return this.number();\n                }\n                else if (this.is_alpha(c)) {\n                    return this.identifier();\n                }\n                else {\n                    diagnostics.report(new diagnostics.Located(new BadCharacter(c), this.span(start_ind)));\n                    return null;\n                }\n        }\n    }\n    string(start_ind) {\n        let lit_start = this.ind;\n        while (!this.at_end() && this.peek() != '\"') {\n            this.advance();\n        }\n        if (this.at_end()) {\n            diagnostics.report(new diagnostics.Located(new UnterminatedString(), this.span(start_ind)));\n            return null;\n        }\n        let lit_end = this.ind;\n        this.advance();\n        let value = this.source.substring(lit_start, lit_end);\n        return new StringLiteral(value);\n    }\n    number() {\n        let start = this.ind - 1;\n        while (this.is_digit_(this.peek())) {\n            this.advance();\n        }\n        if (this.peek() == '.' && this.is_digit_(this.double_peek())) {\n            this.advance();\n            while (this.is_digit_(this.peek()))\n                this.advance();\n        }\n        return new NumberLiteral(parseFloat(this.source.substring(start, this.ind)));\n    }\n    identifier() {\n        let start = this.ind - 1;\n        while (this.is_alphanumeric_(this.peek())) {\n            this.advance();\n        }\n        let str = this.source.substring(start, this.ind);\n        switch (str) {\n            case \"and\": return new And();\n            case \"class\": return new Class();\n            case \"else\": return new Else();\n            case \"false\": return new BoolLiteral(false);\n            case \"for\": return new For();\n            case \"fun\": return new Fun();\n            case \"if\": return new If();\n            case \"nil\": return new Nil();\n            case \"or\": return new Or();\n            case \"print\": return new Print();\n            case \"return\": return new Return();\n            case \"super\": return new Super();\n            case \"this\": return new This();\n            case \"true\": return new BoolLiteral(true);\n            case \"var\": return new Var();\n            case \"while\": return new While();\n            default: return new Identifier(str);\n        }\n    }\n    is_digit(x) {\n        return /\\d/.test(x);\n    }\n    is_digit_(x) {\n        if (x == null) {\n            return false;\n        }\n        return /\\d/.test(x);\n    }\n    is_alpha(x) {\n        return /[a-zA-Z]/.test(x);\n    }\n    is_alphanumeric(x) {\n        return this.is_digit(x) || this.is_alpha(x);\n    }\n    is_alphanumeric_(x) {\n        if (x == null) {\n            return false;\n        }\n        return this.is_digit(x) || this.is_alpha(x);\n    }\n    at_end() {\n        return this.ind >= this.source.length;\n    }\n    peek() {\n        if (this.at_end()) {\n            return null;\n        }\n        else {\n            return this.source[this.ind];\n        }\n    }\n    double_peek() {\n        if (this.ind + 1 >= this.source.length) {\n            return null;\n        }\n        else {\n            return this.source[this.ind + 1];\n        }\n    }\n    advance() {\n        if (this.at_end()) {\n            return null;\n        }\n        else {\n            return this.source[this.ind++];\n        }\n    }\n    match(x) {\n        if (this.peek() == x) {\n            this.advance();\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    span(start) {\n        return new diagnostics.Span(this.source, start, this.ind);\n    }\n}\nfunction lex(input) {\n    return new Lexer(input).lex();\n}\nexports.lex = lex;\n\n\n//# sourceURL=webpack://thing/./build/ts/lexer.js?");

/***/ }),

/***/ "./build/ts/main.js":
/*!**************************!*\
  !*** ./build/ts/main.js ***!
  \**************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst diagnostics = __importStar(__webpack_require__(/*! ./diagnostics */ \"./build/ts/diagnostics.js\"));\nconst lexer = __importStar(__webpack_require__(/*! ./lexer */ \"./build/ts/lexer.js\"));\nconst parser = __importStar(__webpack_require__(/*! ./parser */ \"./build/ts/parser.js\"));\nlet editor = ace.edit(\"codeeditor\");\neditor.setOption(\"printMarginColumn\", false);\ndocument.getElementById('submitbutton').addEventListener('click', function () {\n    let inputcodebox = document.getElementById('inputcodebox');\n    let input = editor.getValue();\n    diagnostics.clear();\n    let result = parser.parse(lexer.lex(input));\n    console.log(result);\n});\n\n\n//# sourceURL=webpack://thing/./build/ts/main.js?");

/***/ }),

/***/ "./build/ts/parser.js":
/*!****************************!*\
  !*** ./build/ts/parser.js ***!
  \****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parse = void 0;\nconst lexer = __importStar(__webpack_require__(/*! ./lexer */ \"./build/ts/lexer.js\"));\nconst ast = __importStar(__webpack_require__(/*! ./ast */ \"./build/ts/ast.js\"));\nconst peg = __importStar(__webpack_require__(/*! ./peg */ \"./build/ts/peg.js\"));\nfunction astify_binary_expr([comp, ops]) {\n    let cur;\n    while (cur = ops.shift()) {\n        let [op, right] = cur;\n        let op_ast;\n        switch (op.type()) {\n            case \"'+'\":\n                op_ast = ast.BinaryOperator.Plus;\n                break;\n            case \"'-'\":\n                op_ast = ast.BinaryOperator.Minus;\n                break;\n            case \"'*'\":\n                op_ast = ast.BinaryOperator.Star;\n                break;\n            case \"'/'\":\n                op_ast = ast.BinaryOperator.Slash;\n                break;\n            case \"'<'\":\n                op_ast = ast.BinaryOperator.Less;\n                break;\n            case \"'='\":\n                op_ast = ast.BinaryOperator.Equal;\n                break;\n            case \"'>'\":\n                op_ast = ast.BinaryOperator.Greater;\n                break;\n            case \"'!'\":\n                op_ast = ast.BinaryOperator.Bang;\n                break;\n            case \"'<='\":\n                op_ast = ast.BinaryOperator.LessEqual;\n                break;\n            case \"'=='\":\n                op_ast = ast.BinaryOperator.EqualEqual;\n                break;\n            case \"'>='\":\n                op_ast = ast.BinaryOperator.GreaterEqual;\n                break;\n            case \"'!='\":\n                op_ast = ast.BinaryOperator.BangEqual;\n                break;\n            default: throw Error('unreachable');\n        }\n        comp = new ast.BinaryExpr(comp, right, op_ast);\n    }\n    return comp;\n}\nlet block;\nlet expression;\nlet expression_indirect = () => expression;\nlet args = new peg.Indirect(expression_indirect).chain(new peg.ZeroMore(new peg.Token(\"','\").chain(new peg.Indirect(expression_indirect)))).apply(([first, more]) => [first].concat(more.map(x => x[1])));\nlet params = new peg.Token(\"identifier\").chain(new peg.ZeroMore(new peg.Token(\"','\").chain(new peg.Token(\"identifier\")))).apply(([first, more]) => [first].concat(more.map(x => x[1])));\nlet fn = new peg.Token(\"identifier\").chain(new peg.Token(\"'('\")).chain(new peg.Optional(params)).chain(new peg.Token(\"')'\")).chain(new peg.Indirect(() => block))\n    .apply(([[[[identifier, oparen], params], cparen], block]) => [identifier, params ? params : [], block]);\nlet primary = new peg.Token('bool literal').apply(tok => new ast.Literal(tok.bool)).choice(new peg.Token(\"'nil'\").apply(tok => new ast.Literal(null))).choice(new peg.Token('number literal').apply(tok => new ast.Literal(tok.num))).choice(new peg.Token('string literal').apply(tok => new ast.Literal(tok.str))).choice(new peg.Token(\"identifier\").apply(ident => new ast.VarExpr(ident.name))).choice(new peg.Token(\"'('\").chain(new peg.Indirect(expression_indirect)).chain(new peg.Token(\"')'\")).apply(([[oparen, expr], cparen]) => expr));\nlet call = primary.chain(new peg.ZeroMore(new peg.Choice(new peg.Token(\"'('\").chain(new peg.Optional(args)).chain(new peg.Token(\"')'\")).apply(([[oparen, args], cparen]) => args), new peg.Token(\"'.'\").chain(new peg.Token(\"identifier\")).apply(([dot, ident]) => ident)))).apply(([expr, ops]) => {\n    let cur_op;\n    while (cur_op = ops.shift()) {\n        if (cur_op instanceof lexer.Identifier) {\n            let ident = cur_op;\n        }\n        else {\n            let args;\n            if (cur_op == null) {\n                args = [];\n            }\n            else {\n                args = cur_op[1];\n            }\n        }\n    }\n    return expr;\n});\nlet unary;\nunary =\n    (new peg.Token(\"'-'\").choice(new peg.Token(\"'!'\"))).chain(new peg.Indirect(() => unary)).apply(([op, expr]) => {\n        let op_ast;\n        switch (op.type()) {\n            case \"'-'\":\n                op_ast = ast.UnaryOperator.Minus;\n                break;\n            case \"'!'\":\n                op_ast = ast.UnaryOperator.Bang;\n                break;\n            default: throw Error('unreachable');\n        }\n        return new ast.UnaryExpr(op_ast, expr);\n    })\n        .choice(call);\nlet factor = new peg.Apply(astify_binary_expr, new peg.Chain(unary, new peg.ZeroMore(new peg.Chain(new peg.Choice(new peg.Token(\"'*'\"), new peg.Token(\"'/'\")), unary))));\nlet term = new peg.Apply(astify_binary_expr, new peg.Chain(factor, new peg.ZeroMore(new peg.Chain(new peg.Choice(new peg.Token(\"'+'\"), new peg.Token(\"'-'\")), factor))));\nlet comparison = new peg.Apply(astify_binary_expr, new peg.Chain(term, new peg.ZeroMore(new peg.Chain(new peg.Choice(new peg.Choice(new peg.Choice(new peg.Token(\"'<'\"), new peg.Token(\"'<='\")), new peg.Token(\"'>'\")), new peg.Token(\"'>='\")), term))));\nlet equality = new peg.Apply(astify_binary_expr, new peg.Chain(comparison, new peg.ZeroMore(new peg.Chain(new peg.Choice(new peg.Token(\"'=='\"), new peg.Token(\"'!='\")), comparison))));\nlet logic_and = equality.chain(new peg.ZeroMore(new peg.Token(\"'and'\").chain(equality))).apply(astify_binary_expr);\nlet logic_or = logic_and.chain(new peg.ZeroMore(new peg.Token(\"'or'\").chain(logic_and))).apply(astify_binary_expr);\nlet assignment;\nassignment =\n    new peg.Optional(call.chain(new peg.Token(\"'.'\"))).chain(new peg.Token(\"identifier\")).chain(new peg.Token(\"'='\")).chain(new peg.Indirect(() => assignment))\n        .apply(([[[m_call, ident], eq], assignment]) => new ast.AssignExpr(ident.name, assignment))\n        .choice(logic_or);\nexpression = assignment;\nlet expr_stmt = new peg.Apply(([expr, semi]) => new ast.ExprStmt(expr), new peg.Chain(new peg.Indirect(expression_indirect), new peg.Token(\"';'\")));\nlet print_stmt = new peg.Apply(([[print, expr], semi]) => new ast.ExprStmt(expr), new peg.Chain(new peg.Chain(new peg.Token(\"'print'\"), new peg.Indirect(expression_indirect)), new peg.Token(\"';'\")));\nlet var_decl;\nlet statement;\nlet statement_indirect = () => statement;\nlet declaration;\nlet declaration_indirect = () => declaration;\nlet for_stmt = new peg.Chain(new peg.Chain(new peg.Chain(new peg.Chain(new peg.Chain(new peg.Chain(new peg.Token(\"'for'\"), new peg.Token(\"'('\")), new peg.Choice(new peg.Choice(new peg.Indirect(() => var_decl), expr_stmt), new peg.Token(\"';'\"))), new peg.Chain(new peg.Optional(new peg.Indirect(expression_indirect)), new peg.Token(\"';'\"))), new peg.Chain(new peg.Optional(new peg.Indirect(expression_indirect)), new peg.Token(\"';'\"))), new peg.Token(\"')'\")), new peg.Indirect(statement_indirect))\n    .apply(([[[[[[for_, oparen], initializer], cond], inc], cparen], body]) => {\n    let initializer_;\n    if (initializer instanceof lexer.Token) {\n        initializer_ = null;\n    }\n    else {\n        initializer_ = initializer;\n    }\n    return new ast.ForStmt(initializer_, cond[0], inc[0], body);\n});\nlet if_stmt = new peg.Apply(([[[[[if_, oparen], cond], cparen], body], m_else]) => new ast.IfStmt(cond, body, m_else ? m_else[1] : null), new peg.Chain(new peg.Chain(new peg.Chain(new peg.Chain(new peg.Chain(new peg.Token(\"'if'\"), new peg.Token(\"'('\")), new peg.Indirect(expression_indirect)), new peg.Token(\"')'\")), new peg.Indirect(statement_indirect)), new peg.Optional(new peg.Chain(new peg.Token(\"'else'\"), new peg.Indirect(statement_indirect)))));\nlet return_stmt = new peg.Apply(([[return_, m_expr], semi]) => new ast.ReturnStmt(m_expr), new peg.Chain(new peg.Chain(new peg.Token(\"'return'\"), new peg.Optional(new peg.Indirect(expression_indirect))), new peg.Token(\"';'\")));\nlet while_stmt = new peg.Apply(([[[[while_, oparen], cond], cparen], body]) => new ast.WhileStmt(cond, body), new peg.Chain(new peg.Chain(new peg.Chain(new peg.Chain(new peg.Token(\"'while'\"), new peg.Token(\"'('\")), new peg.Indirect(expression_indirect)), new peg.Token(\"')'\")), new peg.Indirect(statement_indirect)));\nblock =\n    new peg.Apply(([[obrace, decls], cbrace]) => new ast.BlockStmt(decls), new peg.Chain(new peg.Chain(new peg.Token(\"'{'\"), new peg.ZeroMore(new peg.Indirect(declaration_indirect))), new peg.Token(\"'}'\")));\nstatement =\n    expr_stmt\n        .choice(print_stmt)\n        .choice(for_stmt)\n        .choice(if_stmt)\n        .choice(return_stmt)\n        .choice(while_stmt)\n        .choice(block);\nvar_decl =\n    new peg.Apply(([[[var_, ident], m_initializer], semi]) => new ast.VarStmt(ident.name, m_initializer ? m_initializer[1] : null), new peg.Chain(new peg.Chain(new peg.Chain(new peg.Token(\"'var'\"), new peg.Token(\"identifier\")), new peg.Optional(new peg.Chain(new peg.Token(\"'='\"), new peg.Indirect(expression_indirect)))), new peg.Token(\"';'\")));\nlet fun_decl = new peg.Chain(new peg.Token(\"'fun'\"), fn).apply(([fun, [identifier, params, block]]) => new ast.FunctionStmt(identifier.name, params.map(x => x.name), block));\ndeclaration = new peg.Choice(new peg.Choice(fun_decl, var_decl), statement);\nlet script = new peg.Apply(([stmts, eof]) => stmts, new peg.Chain(new peg.ZeroMore(declaration), new peg.Token(\"eof\")));\nfunction parse([tokens, eof]) {\n    let parser = new peg.Parser(tokens, eof);\n    let location = new peg.ParseLocation(parser, 0);\n    let res = script.parse(parser, location);\n    if (res) {\n        return res[1];\n    }\n    else {\n        parser.report_error();\n        return null;\n    }\n}\nexports.parse = parse;\n\n\n//# sourceURL=webpack://thing/./build/ts/parser.js?");

/***/ }),

/***/ "./build/ts/peg.js":
/*!*************************!*\
  !*** ./build/ts/peg.js ***!
  \*************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Indirect = exports.Apply = exports.OneMore = exports.ZeroMore = exports.Optional = exports.Choice = exports.Chain = exports.Token = exports.PEG = exports.ParseLocation = exports.Parser = void 0;\nconst diagnostics = __importStar(__webpack_require__(/*! ./diagnostics */ \"./build/ts/diagnostics.js\"));\nclass Parser {\n    constructor(tokens, eof) {\n        this.tokens = tokens;\n        this.eof = eof;\n        this.errors = new Map();\n    }\n    error(ind, expect) {\n        if (!this.errors.has(ind)) {\n            this.errors.set(ind, []);\n        }\n        this.errors.get(ind).push(expect);\n    }\n    report_error() {\n        let max_ind = Math.max(...this.errors.keys());\n        let got = this.get_tok(max_ind);\n        let es = this.errors.get(max_ind);\n        let explanation;\n        if (es.length == 1) {\n            explanation = `expected ${es[0]}, got ${got.thing.type()}`;\n        }\n        else {\n            explanation = `expected one of ${es}, got ${got.thing.type()}`;\n        }\n        diagnostics.report(new diagnostics.Located(new diagnostics.Diagnostic(`parse error: ${explanation}`, null), got.span));\n    }\n    get_tok(ind) {\n        if (ind >= this.tokens.length) {\n            return this.eof;\n        }\n        else {\n            return this.tokens[ind];\n        }\n    }\n}\nexports.Parser = Parser;\nclass ParseLocation {\n    constructor(parser, ind) {\n        this.parser = parser;\n        this.ind = ind;\n    }\n    advance() {\n        return new ParseLocation(this.parser, this.ind + 1);\n    }\n    tok() { return this.parser.get_tok(this.ind); }\n}\nexports.ParseLocation = ParseLocation;\nclass PEG {\n    // convenience methods\n    chain(other) {\n        return new Chain(this, other);\n    }\n    choice(other) {\n        return new Choice(this, other);\n    }\n    apply(op) {\n        return new Apply(op, this);\n    }\n}\nexports.PEG = PEG;\nclass Token extends PEG {\n    constructor(type) {\n        super();\n        this.type = type;\n    }\n    parse(parser, location) {\n        let t = location.tok();\n        if (t.thing.type() == this.type) {\n            return [location.advance(), t.thing];\n        }\n        else {\n            parser.error(location.ind, this.type);\n            return null;\n        }\n    }\n}\nexports.Token = Token;\nclass Chain extends PEG {\n    constructor(a, b) {\n        super();\n        this.a = a;\n        this.b = b;\n    }\n    parse(parser, location) {\n        let m_a_res = this.a.parse(parser, location);\n        if (m_a_res) {\n            let [location_, a_res] = m_a_res;\n            let m_b_res = this.b.parse(parser, location_);\n            if (m_b_res) {\n                let [location__, b_res] = m_b_res;\n                return [location__, [a_res, b_res]];\n            }\n        }\n        return null;\n    }\n}\nexports.Chain = Chain;\nclass Choice extends PEG {\n    constructor(a, b) {\n        super();\n        this.a = a;\n        this.b = b;\n    }\n    parse(parser, location) {\n        let m_a_res = this.a.parse(parser, location);\n        if (m_a_res) {\n            return m_a_res;\n        }\n        else {\n            let m_b_res = this.b.parse(parser, location);\n            if (m_b_res) {\n                return m_b_res;\n            }\n        }\n        return null;\n    }\n}\nexports.Choice = Choice;\nclass Optional extends PEG {\n    constructor(a) {\n        super();\n        this.a = a;\n    }\n    parse(parser, location) {\n        let m_a_res = this.a.parse(parser, location);\n        if (m_a_res) {\n            let [location_, a_res] = m_a_res;\n            return [location_, a_res];\n        }\n        else {\n            return [location, null];\n        }\n    }\n}\nexports.Optional = Optional;\nclass ZeroMore extends PEG {\n    constructor(a) {\n        super();\n        this.a = a;\n    }\n    parse(parser, location) {\n        let items = [];\n        while (true) {\n            let m_res = this.a.parse(parser, location);\n            if (m_res) {\n                let [location_, item] = m_res;\n                location = location_;\n                items.push(item);\n            }\n            else {\n                return [location, items];\n            }\n        }\n    }\n}\nexports.ZeroMore = ZeroMore;\nclass OneMore extends PEG {\n    constructor(a) {\n        super();\n        this.a = a;\n    }\n    parse(parser, location) {\n        return new Apply(([first, more]) => [first].concat(more), new Chain(this.a, new ZeroMore(this.a))).parse(parser, location);\n    }\n}\nexports.OneMore = OneMore;\nclass Apply extends PEG {\n    constructor(op, a) {\n        super();\n        this.op = op;\n        this.a = a;\n    }\n    parse(parser, location) {\n        let m_a_res = this.a.parse(parser, location);\n        if (m_a_res) {\n            let [location_, a_res] = m_a_res;\n            let b_res = this.op(a_res);\n            return [location_, b_res];\n        }\n        return null;\n    }\n}\nexports.Apply = Apply;\nclass Indirect extends PEG {\n    constructor(thing) {\n        super();\n        this.thing = thing;\n    }\n    parse(parser, location) {\n        return this.thing().parse(parser, location);\n    }\n}\nexports.Indirect = Indirect;\n\n\n//# sourceURL=webpack://thing/./build/ts/peg.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./build/ts/main.js");
/******/ 	
/******/ })()
;